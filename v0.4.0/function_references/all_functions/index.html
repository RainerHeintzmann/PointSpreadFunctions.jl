<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>List of Functions · PSFs Documentation</title><meta name="title" content="List of Functions · PSFs Documentation"/><meta property="og:title" content="List of Functions · PSFs Documentation"/><meta property="twitter:title" content="List of Functions · PSFs Documentation"/><meta name="description" content="Documentation for PSFs Documentation."/><meta property="og:description" content="Documentation for PSFs Documentation."/><meta property="twitter:description" content="Documentation for PSFs Documentation."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">PSFs Documentation</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">PointSpreadFunctions.jl</a></li><li><span class="tocitem">Workflow</span><ul><li><a class="tocitem" href="../../workflow/PSF_parameters/">PointSpreadFunction parameters</a></li><li><a class="tocitem" href="../../workflow/PSF_generation/">PointSpreadFunction calculation</a></li></ul></li><li><span class="tocitem">Function references</span><ul><li class="is-active"><a class="tocitem" href>List of Functions</a><ul class="internal"><li><a class="tocitem" href="#Parameters"><span>Parameters</span></a></li><li><a class="tocitem" href="#PointSpreadFunction-generation"><span>PointSpreadFunction generation</span></a></li><li><a class="tocitem" href="#Pupils"><span>Pupils</span></a></li><li><a class="tocitem" href="#Polarization"><span>Polarization</span></a></li><li><a class="tocitem" href="#Aplanatic-factors"><span>Aplanatic factors</span></a></li><li><a class="tocitem" href="#Utilities"><span>Utilities</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Function references</a></li><li class="is-active"><a href>List of Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>List of Functions</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/main/docs/src/function_references/all_functions.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="List-of-Functions"><a class="docs-heading-anchor" href="#List-of-Functions">List of Functions</a><a id="List-of-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#List-of-Functions" title="Permalink"></a></h1><h2 id="Parameters"><a class="docs-heading-anchor" href="#Parameters">Parameters</a><a id="Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Parameters" title="Permalink"></a></h2><p>see Workflow</p><h2 id="PointSpreadFunction-generation"><a class="docs-heading-anchor" href="#PointSpreadFunction-generation">PointSpreadFunction generation</a><a id="PointSpreadFunction-generation-1"></a><a class="docs-heading-anchor-permalink" href="#PointSpreadFunction-generation" title="Permalink"></a></h2><p>see Workflow</p><h2 id="Pupils"><a class="docs-heading-anchor" href="#Pupils">Pupils</a><a id="Pupils-1"></a><a class="docs-heading-anchor-permalink" href="#Pupils" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.pupil_θ-Tuple{Any, PSFParams, Any}" href="#PointSpreadFunctions.pupil_θ-Tuple{Any, PSFParams, Any}"><code>PointSpreadFunctions.pupil_θ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pupil_θ(sz, pp::PSFParams, sampling)</code></pre><p>returns the θ angle (to the optical axis) in the sample space as a pupil array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/00bc438188ad1a6fcdb1276344071010324936d6/src/pupil.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.pupil_ϕ-Tuple{Any, PSFParams, Any}" href="#PointSpreadFunctions.pupil_ϕ-Tuple{Any, PSFParams, Any}"><code>PointSpreadFunctions.pupil_ϕ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pupil_ϕ(sz, pp::PSFParams, sampling)</code></pre><p>returns the azimuthal angle ϕ  in the sample space as a pupil array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/00bc438188ad1a6fcdb1276344071010324936d6/src/pupil.jl#L23-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.aplanatic_factor-Tuple{Any, PSFParams, Any}" href="#PointSpreadFunctions.aplanatic_factor-Tuple{Any, PSFParams, Any}"><code>PointSpreadFunctions.aplanatic_factor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">aplanatic_factor(sz, pp::PSFParams, sampling)</code></pre><p>returns the aplanatic factor as specified in <code>pp.aplanatic</code> as a pupil array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/00bc438188ad1a6fcdb1276344071010324936d6/src/pupil.jl#L32-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.pupil_xyz" href="#PointSpreadFunctions.pupil_xyz"><code>PointSpreadFunctions.pupil_xyz</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pupil_xyz(sz, pp, sampling=nothing)</code></pre><p>creates a pupil with electric field distributions in XYZ. Returns a 4D dataset with the electric field components along the 4th dimension. #Arguments</p><ul><li>&#39;sz&#39;:     size of the pupil in pixels</li><li>&#39;pp&#39;:     the <code>PSFParam</code> structure with all the PSF parameters</li><li>&#39;sampling&#39;:   the pixel sampling in the same units as the wavelength</li><li>&#39;is_proj&#39;:    defines whether the pupil is to be interpreted as the projection of the McCutchen pupil or not. This yields a by 1 ./cos(Theta) modified aplanatic factor.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/00bc438188ad1a6fcdb1276344071010324936d6/src/pupil.jl#L86-L95">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.field_xyz-Tuple{Any, Any, Any}" href="#PointSpreadFunctions.field_xyz-Tuple{Any, Any, Any}"><code>PointSpreadFunctions.field_xyz</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">field_xyz(sz, pp, sampling)</code></pre><p>creates a 2D pupil field behind the lens, containing E<em>x, E</em>Y and E_z.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/00bc438188ad1a6fcdb1276344071010324936d6/src/pupil.jl#L77-L81">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.field_xy_to_xyz-Tuple{Any, Any, Any}" href="#PointSpreadFunctions.field_xy_to_xyz-Tuple{Any, Any, Any}"><code>PointSpreadFunctions.field_xy_to_xyz</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">field_xy_to_xyz(field,pp,sampling)</code></pre><p>converts a 2D field at the pupil to a 2D field behind the lens, containing E<em>x, E</em>Y and E_z.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/00bc438188ad1a6fcdb1276344071010324936d6/src/pupil.jl#L55-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.field_pupil" href="#PointSpreadFunctions.field_pupil"><code>PointSpreadFunctions.field_pupil</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">field_pupil(sz, pp, sampling)</code></pre><p>returns the pupil polarization as a 4D array with the XY polarization components stacked along the 4th dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/00bc438188ad1a6fcdb1276344071010324936d6/src/pupil.jl#L46-L50">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.get_propagator-Tuple{Any, Any, Any}" href="#PointSpreadFunctions.get_propagator-Tuple{Any, Any, Any}"><code>PointSpreadFunctions.get_propagator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_propagator(sz,pp,sampling)</code></pre><p>retrieves the propagator phase, prpagating a single Z-slice.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/00bc438188ad1a6fcdb1276344071010324936d6/src/pupil.jl#L108-L112">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.get_propagator_gradient-Tuple{Any, Any, Any}" href="#PointSpreadFunctions.get_propagator_gradient-Tuple{Any, Any, Any}"><code>PointSpreadFunctions.get_propagator_gradient</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_propagator_gradient(prop_phase, scalar, xy_scale)</code></pre><p>calculates the gradient of the propagator along the X and Y directions of the pupil.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/00bc438188ad1a6fcdb1276344071010324936d6/src/pupil.jl#L125-L129">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.apply_propagators-Tuple{Any, Any, PSFParams}" href="#PointSpreadFunctions.apply_propagators-Tuple{Any, Any, PSFParams}"><code>PointSpreadFunctions.apply_propagators</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">apply_propagators(pupil, z_planes, pp::PSFParams; sampling=nothing)</code></pre><p>propagates a given <code>pupil</code> by a number of <code>z_planes</code> (almost) symmetrically in both directions. The result is a stack of propagated pupils. The slice-to-slice propagator is obtained via the <code>get_propagator</code> method.</p><p>See also:</p><ul><li>get_propagator</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/00bc438188ad1a6fcdb1276344071010324936d6/src/aPSFs.jl#L82-L92">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.get_zernike_pupil_phase-Tuple{Any, Any, Any}" href="#PointSpreadFunctions.get_zernike_pupil_phase-Tuple{Any, Any, Any}"><code>PointSpreadFunctions.get_zernike_pupil_phase</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_zernike_pupil_phase(sz, pp, sampling)</code></pre><p>calculates the phases in the pupil for a given set of aberrations as defined by <code>J</code> and <code>coefficients</code>. By default this follows the OSA nomenclature. See the help file of <code>ZernikePolynomials.jl</code> for more information. The pupil phase (up to the pupil border as defined by the <code>NA</code> in <code>pp</code>) is returned.</p><p>Arguments:</p><ul><li><code>sz</code>:  size of the real-space array</li><li><code>pp</code>:  PSF parameter structure</li><li><code>sampling</code>: pixelpitch in real space as NTuple</li></ul><p>Example:</p><pre><code class="language-jdoctest hljs">julia&gt; using PointSpreadFunctions, FFTW

julia&gt; aberr = PointSpreadFunctions.Aberrations([Zernike_Spherical, Zernike_ObliqueAstigmatism],[0.1, 0.2])
Aberrations([12, 3], [0.1, 0.2], :OSA)

julia&gt; pp = PSFParams(580.0, 1.4, 1.518; aberrations=aberr)
PSFParams(580.0, 1.4, 1.518, Float32, ModeWidefield, PointSpreadFunctions.pol_scalar, PointSpreadFunctions.var&quot;#42#43&quot;(), PointSpreadFunctions.MethodPropagateIterative, nothing, Aberrations([12, 3], [0.1, 0.2], :OSA), nothing)

julia&gt; sz = (10,10,64)
(10, 10, 64)

julia&gt; sampling=(190,190,100)
(190, 190, 100)

julia&gt; PointSpreadFunctions.get_zernike_pupil_phase(sz,pp,sampling)
10×10 Matrix{Float64}:
 0.0   0.0         0.0         0.0         0.0         0.0         0.0         0.0         0.0         0.0
 0.0   0.0         0.0         0.533599    0.202003   -0.0206203  -0.170662   -0.21173     0.0         0.0
 0.0   0.0         0.477274    0.186398    0.0287554  -0.104828   -0.250743   -0.3726     -0.361221    0.0
 0.0   0.533599    0.186398    0.0937363   0.0736565   0.016983   -0.112676   -0.278928   -0.3726     -0.21173
 0.0   0.202003    0.0287554   0.0736565   0.154747    0.162853    0.0615812  -0.112676   -0.250743   -0.170662
 0.0  -0.0206203  -0.104828    0.016983    0.162853    0.223607    0.162853    0.016983   -0.104828   -0.0206203
 0.0  -0.170662   -0.250743   -0.112676    0.0615812   0.162853    0.154747    0.0736565   0.0287554   0.202003
 0.0  -0.21173    -0.3726     -0.278928   -0.112676    0.016983    0.0736565   0.0937363   0.186398    0.533599
 0.0   0.0        -0.361221   -0.3726     -0.250743   -0.104828    0.0287554   0.186398    0.477274    0.0
 0.0   0.0         0.0        -0.21173    -0.170662   -0.0206203   0.202003    0.533599    0.0         0.0
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/00bc438188ad1a6fcdb1276344071010324936d6/src/pupil.jl#L152-L194">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.get_zernike_pupil-Tuple{Any, Any, Any}" href="#PointSpreadFunctions.get_zernike_pupil-Tuple{Any, Any, Any}"><code>PointSpreadFunctions.get_zernike_pupil</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_zernike_pupil(sz, pp, sampling)</code></pre><p>calculates the phases in the pupil for a given set of aberrations as defined by <code>J</code> and <code>coefficients</code>. By default this follows the OSA nomenclature. See the help file of <code>ZernikePolynomials.jl</code> for more information. The complex-valued pupil (up to the pupil border as defined by the <code>NA</code> in <code>pp</code>) is returned.</p><p>Arguments:</p><ul><li><code>sz</code>:  size of the real-space array</li><li><code>pp</code>:  PSF parameter structure</li><li><code>sampling</code>: pixelpitch in real space as NTuple</li></ul><p>Example:</p><pre><code class="language-jdoctest hljs">julia&gt; using PointSpreadFunctions, FFTW

julia&gt; aberr = PointSpreadFunctions.Aberrations([Zernike_Spherical, Zernike_ObliqueAstigmatism],[0.1, 0.2])
Aberrations([12, 3], [0.1, 0.2], :OSA)

julia&gt; pp = PSFParams(580.0, 1.4, 1.518; aberrations=aberr)
PSFParams(580.0, 1.4, 1.518, Float32, ModeWidefield, PointSpreadFunctions.pol_scalar, PointSpreadFunctions.var&quot;#42#43&quot;(), PointSpreadFunctions.MethodPropagateIterative, nothing, Aberrations([12, 3], [0.1, 0.2], :OSA), nothing)

julia&gt; sz = (10,10,64)
(10, 10, 64)

julia&gt; sampling=(190,190,100)
(190, 190, 100)

julia&gt; PointSpreadFunctions.get_zernike_pupil(sz,pp,sampling)
10×10 Matrix{ComplexF64}:
 1.0+0.0im        1.0+0.0im               1.0+0.0im             1.0+0.0im               1.0+0.0im       …          1.0+0.0im             1.0+0.0im               1.0+0.0im             1.0+0.0im
 1.0+0.0im        1.0+0.0im               1.0+0.0im       -0.977799-0.209546im     0.297025+0.95487im         0.478105-0.878303im   0.238146-0.971229im          1.0+0.0im             1.0+0.0im
 1.0+0.0im        1.0+0.0im         -0.989823+0.142305im   0.389073+0.921207im     0.983723+0.179694im     -0.00466964-0.999989im  -0.696362-0.717691im    -0.643318-0.765599im        1.0+0.0im
 1.0+0.0im  -0.977799-0.209546im     0.389073+0.921207im   0.831518+0.555499im     0.894807+0.446453im        0.759688-0.650288im  -0.180764-0.983527im    -0.696362-0.717691im   0.238146-0.971229im
 1.0+0.0im   0.297025+0.95487im      0.983723+0.179694im   0.894807+0.446453im     0.563395+0.826187im        0.926073+0.377344im   0.759688-0.650288im  -0.00466964-0.999989im   0.478105-0.878303im
 1.0+0.0im   0.991619-0.129199im     0.790818-0.612051im   0.994312+0.106505im     0.520607+0.853797im  …     0.520607+0.853797im   0.994312+0.106505im     0.790818-0.612051im   0.991619-0.129199im
 1.0+0.0im   0.478105-0.878303im  -0.00466964-0.999989im   0.759688-0.650288im     0.926073+0.377344im        0.563395+0.826187im   0.894807+0.446453im     0.983723+0.179694im   0.297025+0.95487im
 1.0+0.0im   0.238146-0.971229im    -0.696362-0.717691im  -0.180764-0.983527im     0.759688-0.650288im        0.894807+0.446453im   0.831518+0.555499im     0.389073+0.921207im  -0.977799-0.209546im
 1.0+0.0im        1.0+0.0im         -0.643318-0.765599im  -0.696362-0.717691im  -0.00466964-0.999989im        0.983723+0.179694im   0.389073+0.921207im    -0.989823+0.142305im        1.0+0.0im
 1.0+0.0im        1.0+0.0im               1.0+0.0im        0.238146-0.971229im     0.478105-0.878303im        0.297025+0.95487im   -0.977799-0.209546im          1.0+0.0im             1.0+0.0im
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/00bc438188ad1a6fcdb1276344071010324936d6/src/pupil.jl#L218-L260">source</a></section></article><h2 id="Polarization"><a class="docs-heading-anchor" href="#Polarization">Polarization</a><a id="Polarization-1"></a><a class="docs-heading-anchor-permalink" href="#Polarization" title="Permalink"></a></h2><p>These functions can be conveniently supplied to <code>PSFParams()</code> via the named argument <code>polarization</code> </p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.pol_scalar" href="#PointSpreadFunctions.pol_scalar"><code>PointSpreadFunctions.pol_scalar</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pol_scalar(T, xypos)</code></pre><p>ignores polarization aspects in the calculation but calculates only based on (high-NA) scalar theory. This is a lot faster but not as accurate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/00bc438188ad1a6fcdb1276344071010324936d6/src/pupil_pol.jl#L4-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.pol_scalar_spiral" href="#PointSpreadFunctions.pol_scalar_spiral"><code>PointSpreadFunctions.pol_scalar_spiral</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pol_scalar_spiral(T, xypos)</code></pre><p>ignores polarization aspects in the calculation but calculates only based on (high-NA) scalar theory. This version still includes a (scalar) phase spiral. This is a lot faster but not as accurate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/00bc438188ad1a6fcdb1276344071010324936d6/src/pupil_pol.jl#L15-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.pol_x" href="#PointSpreadFunctions.pol_x"><code>PointSpreadFunctions.pol_x</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pol_x(T, xypos)</code></pre><p>assumes x-polarization in illumination or an x-oriented polarizer in detection.  In a high-NA objective this is converted into XYZ electric fields at the focus.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/00bc438188ad1a6fcdb1276344071010324936d6/src/pupil_pol.jl#L26-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.pol_y" href="#PointSpreadFunctions.pol_y"><code>PointSpreadFunctions.pol_y</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pol_y(T, xypos)</code></pre><p>assumes y-polarization in illumination or an x-oriented polarizer in detection.  In a high-NA objective this is converted into XYZ electric fields at the focus.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/00bc438188ad1a6fcdb1276344071010324936d6/src/pupil_pol.jl#L36-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.pol_circ" href="#PointSpreadFunctions.pol_circ"><code>PointSpreadFunctions.pol_circ</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pol_circ(T, xypos)</code></pre><p>assumes circular polarization in illumination or an x-oriented polarizer in detection.  In a high-NA objective this is converted into XYZ electric fields at the focus.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/00bc438188ad1a6fcdb1276344071010324936d6/src/pupil_pol.jl#L46-L51">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.pol_circ_spiral" href="#PointSpreadFunctions.pol_circ_spiral"><code>PointSpreadFunctions.pol_circ_spiral</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pol_circ_spiral(T, xypos)</code></pre><p>assumes circular polarization in illumination or an x-oriented polarizer in detection.  This version includes phase spiral defining the local (xypos-dependent) phase of both x and y polarization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/00bc438188ad1a6fcdb1276344071010324936d6/src/pupil_pol.jl#L56-L61">source</a></section></article><h2 id="Aplanatic-factors"><a class="docs-heading-anchor" href="#Aplanatic-factors">Aplanatic factors</a><a id="Aplanatic-factors-1"></a><a class="docs-heading-anchor-permalink" href="#Aplanatic-factors" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.aplanatic_detection" href="#PointSpreadFunctions.aplanatic_detection"><code>PointSpreadFunctions.aplanatic_detection</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">aplanatic_detection = (θ) -&gt; sqrt.(max.(0,cos.(θ)))</code></pre><p>This is the aplanatic factor typically used in detection of fluorescence of (randomly oriented) fluorophores. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/00bc438188ad1a6fcdb1276344071010324936d6/src/aplanatic.jl#L11-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.aplanatic_illumination" href="#PointSpreadFunctions.aplanatic_illumination"><code>PointSpreadFunctions.aplanatic_illumination</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">aplanatic_illumination = (θ) -&gt; sqrt.(max.(0,cos.(θ)))</code></pre><p>This is the aplanatic factor typically used in illumination of (randomly oriented) fluorophores. Note that it is identical to detection.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/00bc438188ad1a6fcdb1276344071010324936d6/src/aplanatic.jl#L18-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.aplanatic_const" href="#PointSpreadFunctions.aplanatic_const"><code>PointSpreadFunctions.aplanatic_const</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">aplanatic_const = (θ) -&gt; one.(eltype(θ))</code></pre><p>This is a constant aplanatic factor</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/00bc438188ad1a6fcdb1276344071010324936d6/src/aplanatic.jl#L25-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.aplanatic_illumination_flux" href="#PointSpreadFunctions.aplanatic_illumination_flux"><code>PointSpreadFunctions.aplanatic_illumination_flux</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">aplanatic_illumination_flux = (θ) -&gt; max.(0,cos.(θ))</code></pre><p>This refers the aplanatic factor if interested in the flux through a detector perpendicular to the optical axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/00bc438188ad1a6fcdb1276344071010324936d6/src/aplanatic.jl#L32-L36">source</a></section></article><h2 id="Utilities"><a class="docs-heading-anchor" href="#Utilities">Utilities</a><a id="Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.amp_to_int-Tuple{Any}" href="#PointSpreadFunctions.amp_to_int-Tuple{Any}"><code>PointSpreadFunctions.amp_to_int</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">amp_to_int(field, pp)</code></pre><p>converts a complex-valued amplitude field to intensity via <code>abs2.</code> and summing over the 4th dimension and dropping the 4th dimension. If <code>pp.transition_dipole</code> is provided, the dipole transition probability is calculated, otherwise a directionally independed effect is assumed.</p><p>#Arguments</p><ul><li>field:    The 4D field to extract the intensity from</li><li>pp:       Is checked for whether <code>pp.transition_dipole</code> is not nothing. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/00bc438188ad1a6fcdb1276344071010324936d6/src/util.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.has_z_symmetry-Tuple{PSFParams}" href="#PointSpreadFunctions.has_z_symmetry-Tuple{PSFParams}"><code>PointSpreadFunctions.has_z_symmetry</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">has_z_symmetry(pp::PSFParams)</code></pre><p>checks whether the point spread function is expected to be symmetric along the z-direction. Currently this is defined by the aberration list being empty.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/00bc438188ad1a6fcdb1276344071010324936d6/src/util.jl#L20-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.get_Abbe_limit-Tuple{PSFParams}" href="#PointSpreadFunctions.get_Abbe_limit-Tuple{PSFParams}"><code>PointSpreadFunctions.get_Abbe_limit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_Abbe_limit(pp::PSFParams)</code></pre><p>returns the Abbe limit of incoherent imaging in real space as a Tuple with 3 entries. Note that the coherent limit needs only a factor of two less sampling, as long as no intensity is calculated. This allows upsampling right before calculating intensities.</p><p>See also:</p><ul><li>get<em>required</em>amp_sampling()</li></ul><p>Example:</p><pre><code class="language-jdoctest hljs">julia&gt; using PointSpreadFunctions

julia&gt; pp = PSFParams(580.0, 1.4, 1.518)
PSFParams(580.0, 1.4, 1.518, Float32, ModeWidefield, PointSpreadFunctions.pol_scalar, PointSpreadFunctions.var&quot;#42#43&quot;(), PointSpreadFunctions.MethodPropagateIterative, nothing, Aberrations(Any[], Any[], :OSA), nothing)

julia&gt; PointSpreadFunctions.get_Abbe_limit(pp)
(191.04085f0, 191.04085f0, 622.8464f0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/00bc438188ad1a6fcdb1276344071010324936d6/src/util.jl#L29-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.get_required_amp_sampling-Tuple{Tuple{Vararg{T, N}} where {N, T}, PSFParams}" href="#PointSpreadFunctions.get_required_amp_sampling-Tuple{Tuple{Vararg{T, N}} where {N, T}, PSFParams}"><code>PointSpreadFunctions.get_required_amp_sampling</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_required_amp_sampling(sz::NTuple, pp::PSFParams)</code></pre><p>returns the necessary sampling (in real space) for sampling amplitudes. This is almost corresponding to the Abbe limit. Factor of two less because of amplitude but twice because of the Nyquist theorem.  However, this is slight modified by requiring slightly higher sampling (one empty pixel on each side of Fourier space) to stay clear of ambiguities.</p><p>See also:</p><ul><li>get<em>Abbe</em>limit()</li></ul><p>Example:</p><pre><code class="language-jdoctest hljs">julia&gt; using PointSpreadFunctions

julia&gt; pp = PSFParams(580.0, 1.4, 1.518)
PSFParams(580.0, 1.4, 1.518, Float32, ModeWidefield, PointSpreadFunctions.pol_scalar, PointSpreadFunctions.var&quot;#42#43&quot;(), PointSpreadFunctions.MethodPropagateIterative, nothing, Aberrations(Any[], Any[], :OSA), nothing)

julia&gt; sz = (256,256,64)
(256, 256, 64)

julia&gt; PointSpreadFunctions.get_required_amp_sampling(sz,pp)
(188.05583f0, 188.05583f0, 219.73679f0)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/00bc438188ad1a6fcdb1276344071010324936d6/src/util.jl#L79-L102">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.get_Ewald_sampling-Tuple{Tuple{Vararg{T, N}} where {N, T}, PSFParams}" href="#PointSpreadFunctions.get_Ewald_sampling-Tuple{Tuple{Vararg{T, N}} where {N, T}, PSFParams}"><code>PointSpreadFunctions.get_Ewald_sampling</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_Ewald_sampling(sz::NTuple, pp::PSFParams)</code></pre><p>returns the required minimum sampling for the calculation of a full Ewald sphere.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/00bc438188ad1a6fcdb1276344071010324936d6/src/util.jl#L109-L113">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.get_McCutchen_kz_center-Tuple{Any, PSFParams, Any}" href="#PointSpreadFunctions.get_McCutchen_kz_center-Tuple{Any, PSFParams, Any}"><code>PointSpreadFunctions.get_McCutchen_kz_center</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_McCutchen_kz_center(ft_shell, pp::PSFParams, sampling)</code></pre><p>calculates the (rounded) pixels position half way between both, the kz-borders of the McCutchen pupil to extract from the full sized Ewald sphere. The pixel z position is returned together with the corresponding kz position.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/00bc438188ad1a6fcdb1276344071010324936d6/src/util.jl#L121-L126">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.limit_kz-Tuple{Any, PSFParams, Any}" href="#PointSpreadFunctions.limit_kz-Tuple{Any, PSFParams, Any}"><code>PointSpreadFunctions.limit_kz</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">limit_k_z(ft_shell, pp::PSFParams, sampling)</code></pre><p>limits the k_z range of the ewald-sphere. returns the extracted region and the new sampling</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/00bc438188ad1a6fcdb1276344071010324936d6/src/util.jl#L137-L142">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.sinc_r-Tuple{Tuple{Vararg{T, N}} where {N, T}, PSFParams}" href="#PointSpreadFunctions.sinc_r-Tuple{Tuple{Vararg{T, N}} where {N, T}, PSFParams}"><code>PointSpreadFunctions.sinc_r</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sinc_r(sz::NTuple, pp::PSFParams; sampling=nothing)</code></pre><p>calculates the 3-dimensional <code>sinc(abs(position))</code> scaled such that the Fourier transformation yields the k-sphere. Note that for this to work the sampling needs to be sufficient, which may be problematic especially along the z-direction. This can be checked with the help of the <code>get_Ewald_sampling()</code> function.</p><p>See also:</p><ul><li>get<em>Ewald</em>sampling()</li><li>jinc<em>r</em>2d</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/00bc438188ad1a6fcdb1276344071010324936d6/src/util.jl#L153-L164">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.jinc_r_2d-Tuple{Tuple{Vararg{T, N}} where {N, T}, PSFParams}" href="#PointSpreadFunctions.jinc_r_2d-Tuple{Tuple{Vararg{T, N}} where {N, T}, PSFParams}"><code>PointSpreadFunctions.jinc_r_2d</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">jinc_r_2d(sz::NTuple, pp::PSFParams; sampling=nothing)</code></pre><p>calculates a jinc(abs(position)) function in 2D such that its Fourier transform corresponds to the disk-shaped pupil (indcluding the effect ot the numerical aperture). If <code>sampling</code> is not provided, sampling is assumed such that the Nyquist sampling would correspond to sampling the wavelength (i.e. the Ewals sphere) correctly for this amplitude.</p><p>See also:</p><ul><li>sinc_r()</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/00bc438188ad1a6fcdb1276344071010324936d6/src/util.jl#L172-L181">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.my_disc-Tuple{Any, Any}" href="#PointSpreadFunctions.my_disc-Tuple{Any, Any}"><code>PointSpreadFunctions.my_disc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">my_disc(sz, pp)</code></pre><p>creates a disc such that there is no overalp upon wrap-around, when convolving it with itself on this grid. This is the radius where there is no overlap. However, in the cornes of the calculation, the results are not 100% accurate as something is missing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/00bc438188ad1a6fcdb1276344071010324936d6/src/util.jl#L288-L294">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.iftz-Tuple{Any}" href="#PointSpreadFunctions.iftz-Tuple{Any}"><code>PointSpreadFunctions.iftz</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">iftz(arr)</code></pre><p>inverse Fourier transform only along the 3rd dimension (kz).</p><p>Arguments:</p><ul><li>arr:  array to transform along kz</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/00bc438188ad1a6fcdb1276344071010324936d6/src/util.jl#L298-L305">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.theta_z-Tuple{Any}" href="#PointSpreadFunctions.theta_z-Tuple{Any}"><code>PointSpreadFunctions.theta_z</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">theta_z(sz)</code></pre><p>a θ function along the z direction, being one for z positon &gt; 0 and zero elsewhere.</p><p>Arguments:</p><ul><li>sz:  size of the array</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/00bc438188ad1a6fcdb1276344071010324936d6/src/util.jl#L308-L315">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.k_0-Tuple{PSFParams}" href="#PointSpreadFunctions.k_0-Tuple{PSFParams}"><code>PointSpreadFunctions.k_0</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">k_0(pp::PSFParams)</code></pre><p>k in the medium as n/lambda.   (1/space units)</p><p>Arguments:</p><ul><li><code>pp</code>:  PSF parameter structure</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/00bc438188ad1a6fcdb1276344071010324936d6/src/util.jl#L320-L327">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.k_pupil-Tuple{PSFParams}" href="#PointSpreadFunctions.k_pupil-Tuple{PSFParams}"><code>PointSpreadFunctions.k_pupil</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">k_pupil(pp::PSFParams)</code></pre><p>maxim radial (i.e. XY-) k-coordinate (1/space units) where the pupil ends</p><p>Arguments:</p><ul><li><code>pp</code>:  PSF parameter structure</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/00bc438188ad1a6fcdb1276344071010324936d6/src/util.jl#L332-L339">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.k_dz-Tuple{PSFParams}" href="#PointSpreadFunctions.k_dz-Tuple{PSFParams}"><code>PointSpreadFunctions.k_dz</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">k_dz(pp::PSFParams)</code></pre><p>relative kz range from pupil boarder to top of Ewald sphere (in 1/space units)</p><p>Arguments:</p><ul><li><code>pp</code>:  PSF parameter structure</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/00bc438188ad1a6fcdb1276344071010324936d6/src/util.jl#L344-L351">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.k_scale-Tuple{Any, PSFParams, Any}" href="#PointSpreadFunctions.k_scale-Tuple{Any, PSFParams, Any}"><code>PointSpreadFunctions.k_scale</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">k_scale(sz,pp,sampling)
pixelpitch (as NTuple) in k-space</code></pre><ul><li><code>sz</code>:  size of the real-space array</li><li><code>pp</code>:  PSF parameter structure</li><li><code>sampling</code>: pixelpitch in real space as NTuple</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/00bc438188ad1a6fcdb1276344071010324936d6/src/util.jl#L369-L375">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.k_pupil_pos-Tuple{Any, PSFParams, Any}" href="#PointSpreadFunctions.k_pupil_pos-Tuple{Any, PSFParams, Any}"><code>PointSpreadFunctions.k_pupil_pos</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">k_pupil_pos(sz, pp::PSFParams, sampling)</code></pre><p>returns the X and Y position of the pupil border in reciprocal space pixels.</p><p>Arguments:</p><ul><li><code>sz</code>:  size of the real-space array</li><li><code>pp</code>:  PSF parameter structure</li><li><code>sampling</code>: pixelpitch in real space as NTuple</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/00bc438188ad1a6fcdb1276344071010324936d6/src/util.jl#L380-L389">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.k_0_pos-Tuple{Any, PSFParams, Any}" href="#PointSpreadFunctions.k_0_pos-Tuple{Any, PSFParams, Any}"><code>PointSpreadFunctions.k_0_pos</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">k_0_pos(sz, pp::PSFParams, sampling)</code></pre><p>returns the X, Y and Z position of the Ewald-sphere border in reciprocal space pixels.</p><p>Arguments:</p><ul><li><code>sz</code>:  size of the real-space array</li><li><code>pp</code>:  PSF parameter structure</li><li><code>sampling</code>: pixelpitch in real space as NTuple</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/00bc438188ad1a6fcdb1276344071010324936d6/src/util.jl#L394-L403">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.k_r-Tuple{Any, PSFParams, Any}" href="#PointSpreadFunctions.k_r-Tuple{Any, PSFParams, Any}"><code>PointSpreadFunctions.k_r</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">k_r(sz, pp::PSFParams, sampling)</code></pre><p>returns an array of radial k coordinates, |k_xy|</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/00bc438188ad1a6fcdb1276344071010324936d6/src/util.jl#L408-L412">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.k_xy-Tuple{Any, Any, Any}" href="#PointSpreadFunctions.k_xy-Tuple{Any, Any, Any}"><code>PointSpreadFunctions.k_xy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">k_xy(sz,pp,sampling)</code></pre><p>yields a 2D array with each entry being a 2D Tuple.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/00bc438188ad1a6fcdb1276344071010324936d6/src/util.jl#L417-L421">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.k_xy_rel_pupil-Tuple{Any, Any, Any}" href="#PointSpreadFunctions.k_xy_rel_pupil-Tuple{Any, Any, Any}"><code>PointSpreadFunctions.k_xy_rel_pupil</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">k_xy_rel_pupil(sz,pp,sampling)</code></pre><p>returns an array of relative distance to the pupil border</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/00bc438188ad1a6fcdb1276344071010324936d6/src/util.jl#L426-L430">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.check_amp_sampling_xy-Tuple{Any, Any, Any}" href="#PointSpreadFunctions.check_amp_sampling_xy-Tuple{Any, Any, Any}"><code>PointSpreadFunctions.check_amp_sampling_xy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_amp_sampling_xy(sz, pp,sampling)</code></pre><p>issues a warning if the amplitude sampling along X and Y is not within the required limits.</p><p>See also:</p><ul><li>get<em>Abbe</em>limit()</li><li>get<em>required</em>amp_sampling()</li><li>check<em>amp</em>sampling()</li><li>check<em>amp</em>sampling_z()</li></ul><p>Arguments:</p><ul><li><code>sz</code>:  size of the real-space array</li><li><code>pp</code>:  PSF parameter structure</li><li><code>sampling</code>: pixelpitch in real space as NTuple</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/00bc438188ad1a6fcdb1276344071010324936d6/src/util.jl#L446-L461">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.check_amp_sampling_z-Tuple{Any, Any, Any}" href="#PointSpreadFunctions.check_amp_sampling_z-Tuple{Any, Any, Any}"><code>PointSpreadFunctions.check_amp_sampling_z</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_amp_sampling_z(sz, pp,sampling)</code></pre><p>issues a warning if the amplitude sampling along Z is not within the required limits.</p><p>See also:</p><ul><li>get<em>Abbe</em>limit()</li><li>get<em>required</em>amp_sampling()</li><li>check<em>amp</em>sampling_xy()</li><li>check<em>amp</em>sampling()</li></ul><p>Arguments:</p><ul><li><code>sz</code>:  size of the real-space array</li><li><code>pp</code>:  PSF parameter structure</li><li><code>sampling</code>: pixelpitch in real space as NTuple</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/00bc438188ad1a6fcdb1276344071010324936d6/src/util.jl#L474-L489">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.check_amp_sampling-Tuple{Any, Any, Any}" href="#PointSpreadFunctions.check_amp_sampling-Tuple{Any, Any, Any}"><code>PointSpreadFunctions.check_amp_sampling</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_amp_sampling(sz, pp,sampling)</code></pre><p>issues a warning if the amplitude sampling (X,Y and Z) is not within the required limits.</p><p>See also:</p><ul><li>get<em>Abbe</em>limit()</li><li>get<em>required</em>amp_sampling()</li><li>check<em>amp</em>sampling_xy()</li><li>check<em>amp</em>sampling_z()</li></ul><p>Arguments:</p><ul><li><code>sz</code>:  size of the real-space array</li><li><code>pp</code>:  PSF parameter structure</li><li><code>sampling</code>: pixelpitch in real space as NTuple</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/00bc438188ad1a6fcdb1276344071010324936d6/src/util.jl#L506-L521">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.check_amp_sampling_sincr-Tuple{Any, Any, Any}" href="#PointSpreadFunctions.check_amp_sampling_sincr-Tuple{Any, Any, Any}"><code>PointSpreadFunctions.check_amp_sampling_sincr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_amp_sampling_sincr(sz, pp,sampling)</code></pre><p>issues a warning if the amplitude sampling (X,Y and Z) is not within the required limits for the <code>SincR</code> method, as this requires sampling the Ewald-sphere according to Nyquist.</p><p>See also:</p><ul><li>get<em>Abbe</em>limit()</li><li>get<em>required</em>amp_sampling()</li><li>check<em>amp</em>sampling()</li><li>get<em>Ewald</em>sampling()</li></ul><p>Arguments:</p><ul><li><code>sz</code>:  size of the real-space array</li><li><code>pp</code>:  PSF parameter structure</li><li><code>sampling</code>: pixelpitch in real space as NTuple</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/00bc438188ad1a6fcdb1276344071010324936d6/src/util.jl#L527-L543">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../workflow/PSF_generation/">« PointSpreadFunction calculation</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.3.0 on <span class="colophon-date" title="Monday 29 April 2024 12:09">Monday 29 April 2024</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
