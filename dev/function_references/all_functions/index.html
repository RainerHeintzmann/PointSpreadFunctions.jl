<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>List of Functions · PSFs Documentation</title><meta name="title" content="List of Functions · PSFs Documentation"/><meta property="og:title" content="List of Functions · PSFs Documentation"/><meta property="twitter:title" content="List of Functions · PSFs Documentation"/><meta name="description" content="Documentation for PSFs Documentation."/><meta property="og:description" content="Documentation for PSFs Documentation."/><meta property="twitter:description" content="Documentation for PSFs Documentation."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">PSFs Documentation</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">PointSpreadFunctions.jl</a></li><li><span class="tocitem">Workflow</span><ul><li><a class="tocitem" href="../../workflow/PSF_parameters/">PointSpreadFunction parameters</a></li><li><a class="tocitem" href="../../workflow/PSF_generation/">PointSpreadFunction calculation</a></li></ul></li><li><span class="tocitem">Function references</span><ul><li class="is-active"><a class="tocitem" href>List of Functions</a><ul class="internal"><li><a class="tocitem" href="#Parameters"><span>Parameters</span></a></li><li><a class="tocitem" href="#PointSpreadFunction-generation"><span>PointSpreadFunction generation</span></a></li><li><a class="tocitem" href="#Pupils"><span>Pupils</span></a></li><li><a class="tocitem" href="#Polarization"><span>Polarization</span></a></li><li><a class="tocitem" href="#Aplanatic-factors"><span>Aplanatic factors</span></a></li><li><a class="tocitem" href="#Sampling"><span>Sampling</span></a></li><li><a class="tocitem" href="#Utilities"><span>Utilities</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Function references</a></li><li class="is-active"><a href>List of Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>List of Functions</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/main/docs/src/function_references/all_functions.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="List-of-Functions"><a class="docs-heading-anchor" href="#List-of-Functions">List of Functions</a><a id="List-of-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#List-of-Functions" title="Permalink"></a></h1><h2 id="Parameters"><a class="docs-heading-anchor" href="#Parameters">Parameters</a><a id="Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Parameters" title="Permalink"></a></h2><p>see Workflow</p><h2 id="PointSpreadFunction-generation"><a class="docs-heading-anchor" href="#PointSpreadFunction-generation">PointSpreadFunction generation</a><a id="PointSpreadFunction-generation-1"></a><a class="docs-heading-anchor-permalink" href="#PointSpreadFunction-generation" title="Permalink"></a></h2><p>see Workflow</p><h2 id="Pupils"><a class="docs-heading-anchor" href="#Pupils">Pupils</a><a id="Pupils-1"></a><a class="docs-heading-anchor-permalink" href="#Pupils" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.pupil_θ-Tuple{Any, PSFParams, Any}" href="#PointSpreadFunctions.pupil_θ-Tuple{Any, PSFParams, Any}"><code>PointSpreadFunctions.pupil_θ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pupil_θ(sz, pp::PSFParams, sampling)</code></pre><p>returns the θ angle (to the optical axis) in the sample space as a pupil array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/8415cb7d3e16c63b8d5d2c339613dbe91f330f3d/src/pupil.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.pupil_ϕ-Tuple{Any, PSFParams, Any}" href="#PointSpreadFunctions.pupil_ϕ-Tuple{Any, PSFParams, Any}"><code>PointSpreadFunctions.pupil_ϕ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pupil_ϕ(sz, pp::PSFParams, sampling)</code></pre><p>returns the azimuthal angle ϕ  in the sample space as a pupil array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/8415cb7d3e16c63b8d5d2c339613dbe91f330f3d/src/pupil.jl#L23-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.aplanatic_factor-Tuple{Any, PSFParams, Any}" href="#PointSpreadFunctions.aplanatic_factor-Tuple{Any, PSFParams, Any}"><code>PointSpreadFunctions.aplanatic_factor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">aplanatic_factor(sz, pp::PSFParams, sampling)</code></pre><p>returns the aplanatic factor as specified in <code>pp.aplanatic</code> as a pupil array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/8415cb7d3e16c63b8d5d2c339613dbe91f330f3d/src/pupil.jl#L32-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.pupil_xyz" href="#PointSpreadFunctions.pupil_xyz"><code>PointSpreadFunctions.pupil_xyz</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pupil_xyz(sz, pp, sampling=nothing)</code></pre><p>creates a pupil with electric field distributions in XYZ. Returns a 4D dataset with the electric field components along the 4th dimension. #Arguments</p><ul><li>&#39;sz&#39;:     size of the pupil in pixels</li><li>&#39;pp&#39;:     the <code>PSFParam</code> structure with all the PSF parameters</li><li>&#39;sampling&#39;:   the pixel sampling in the same units as the wavelength</li><li>&#39;is_proj&#39;:    defines whether the pupil is to be interpreted as the projection of the McCutchen pupil or not. This yields a by 1 ./cos(Theta) modified aplanatic factor.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/8415cb7d3e16c63b8d5d2c339613dbe91f330f3d/src/pupil.jl#L86-L95">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.field_xyz-Tuple{Any, Any, Any}" href="#PointSpreadFunctions.field_xyz-Tuple{Any, Any, Any}"><code>PointSpreadFunctions.field_xyz</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">field_xyz(sz, pp, sampling)</code></pre><p>creates a 2D pupil field behind the lens, containing E<em>x, E</em>Y and E_z.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/8415cb7d3e16c63b8d5d2c339613dbe91f330f3d/src/pupil.jl#L77-L81">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.field_xy_to_xyz-Tuple{Any, Any, Any}" href="#PointSpreadFunctions.field_xy_to_xyz-Tuple{Any, Any, Any}"><code>PointSpreadFunctions.field_xy_to_xyz</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">field_xy_to_xyz(field,pp,sampling)</code></pre><p>converts a 2D field at the pupil to a 2D field behind the lens, containing E<em>x, E</em>Y and E_z.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/8415cb7d3e16c63b8d5d2c339613dbe91f330f3d/src/pupil.jl#L55-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.field_pupil" href="#PointSpreadFunctions.field_pupil"><code>PointSpreadFunctions.field_pupil</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">field_pupil(sz, pp, sampling)</code></pre><p>returns the pupil polarization as a 4D array with the XY polarization components stacked along the 4th dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/8415cb7d3e16c63b8d5d2c339613dbe91f330f3d/src/pupil.jl#L46-L50">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.get_propagator-Tuple{Any, Any, Any}" href="#PointSpreadFunctions.get_propagator-Tuple{Any, Any, Any}"><code>PointSpreadFunctions.get_propagator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_propagator(sz,pp,sampling)</code></pre><p>retrieves the propagator phase, prpagating a single Z-slice.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/8415cb7d3e16c63b8d5d2c339613dbe91f330f3d/src/pupil.jl#L108-L112">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.get_propagator_gradient-Tuple{Any, Any, Any}" href="#PointSpreadFunctions.get_propagator_gradient-Tuple{Any, Any, Any}"><code>PointSpreadFunctions.get_propagator_gradient</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_propagator_gradient(prop_phase, scalar, xy_scale)</code></pre><p>calculates the gradient of the propagator along the X and Y directions of the pupil.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/8415cb7d3e16c63b8d5d2c339613dbe91f330f3d/src/pupil.jl#L125-L129">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.apply_propagators-Tuple{Any, Any, PSFParams}" href="#PointSpreadFunctions.apply_propagators-Tuple{Any, Any, PSFParams}"><code>PointSpreadFunctions.apply_propagators</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">apply_propagators(pupil, z_planes, pp::PSFParams; sampling=nothing)</code></pre><p>propagates a given <code>pupil</code> by a number of <code>z_planes</code> (almost) symmetrically in both directions. The result is a stack of propagated pupils. The slice-to-slice propagator is obtained via the <code>get_propagator</code> method.</p><p>See also:</p><ul><li>get_propagator</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/8415cb7d3e16c63b8d5d2c339613dbe91f330f3d/src/aPSFs.jl#L240-L250">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.get_zernike_pupil_phase-Tuple{Any, Any, Any}" href="#PointSpreadFunctions.get_zernike_pupil_phase-Tuple{Any, Any, Any}"><code>PointSpreadFunctions.get_zernike_pupil_phase</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_zernike_pupil_phase(sz, pp, sampling)</code></pre><p>calculates the phases in the pupil for a given set of aberrations as defined by <code>J</code> and <code>coefficients</code>. By default this follows the OSA nomenclature. See the help file of <code>ZernikePolynomials.jl</code> for more information. The pupil phase (up to the pupil border as defined by the <code>NA</code> in <code>pp</code>) is returned.</p><p>Arguments:</p><ul><li><code>sz</code>:  size of the real-space array</li><li><code>pp</code>:  PSF parameter structure</li><li><code>sampling</code>: pixelpitch in real space as NTuple</li></ul><p>Example:</p><pre><code class="language-jdoctest hljs">julia&gt; using PointSpreadFunctions, FFTW

julia&gt; aberr = PointSpreadFunctions.Aberrations([Zernike_Spherical, Zernike_ObliqueAstigmatism],[0.1, 0.2])
Aberrations([12, 3], [0.1, 0.2], :OSA)

julia&gt; pp = PSFParams(580.0, 1.4, 1.518; aberrations=aberr)
PSFParams(580.0, 1.4, 1.518, Float32, ModeWidefield, PointSpreadFunctions.pol_scalar, PointSpreadFunctions.var&quot;#42#43&quot;(), PointSpreadFunctions.MethodPropagateIterative, nothing, Aberrations([12, 3], [0.1, 0.2], :OSA), nothing)

julia&gt; sz = (10,10,64)
(10, 10, 64)

julia&gt; sampling=(190,190,100)
(190, 190, 100)

julia&gt; PointSpreadFunctions.get_zernike_pupil_phase(sz,pp,sampling)
10×10 Matrix{Float64}:
 0.0   0.0         0.0         0.0         0.0         0.0         0.0         0.0         0.0         0.0
 0.0   0.0         0.0         0.533599    0.202003   -0.0206203  -0.170662   -0.21173     0.0         0.0
 0.0   0.0         0.477274    0.186398    0.0287554  -0.104828   -0.250743   -0.3726     -0.361221    0.0
 0.0   0.533599    0.186398    0.0937363   0.0736565   0.016983   -0.112676   -0.278928   -0.3726     -0.21173
 0.0   0.202003    0.0287554   0.0736565   0.154747    0.162853    0.0615812  -0.112676   -0.250743   -0.170662
 0.0  -0.0206203  -0.104828    0.016983    0.162853    0.223607    0.162853    0.016983   -0.104828   -0.0206203
 0.0  -0.170662   -0.250743   -0.112676    0.0615812   0.162853    0.154747    0.0736565   0.0287554   0.202003
 0.0  -0.21173    -0.3726     -0.278928   -0.112676    0.016983    0.0736565   0.0937363   0.186398    0.533599
 0.0   0.0        -0.361221   -0.3726     -0.250743   -0.104828    0.0287554   0.186398    0.477274    0.0
 0.0   0.0         0.0        -0.21173    -0.170662   -0.0206203   0.202003    0.533599    0.0         0.0
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/8415cb7d3e16c63b8d5d2c339613dbe91f330f3d/src/pupil.jl#L152-L194">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.get_zernike_pupil-Tuple{Any, Any, Any}" href="#PointSpreadFunctions.get_zernike_pupil-Tuple{Any, Any, Any}"><code>PointSpreadFunctions.get_zernike_pupil</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_zernike_pupil(sz, pp, sampling)</code></pre><p>calculates the phases in the pupil for a given set of aberrations as defined by <code>J</code> and <code>coefficients</code>. By default this follows the OSA nomenclature. See the help file of <code>ZernikePolynomials.jl</code> for more information. The complex-valued pupil (up to the pupil border as defined by the <code>NA</code> in <code>pp</code>) is returned.</p><p>Arguments:</p><ul><li><code>sz</code>:  size of the real-space array</li><li><code>pp</code>:  PSF parameter structure</li><li><code>sampling</code>: pixelpitch in real space as NTuple</li></ul><p>Example:</p><pre><code class="language-jdoctest hljs">julia&gt; using PointSpreadFunctions, FFTW

julia&gt; aberr = PointSpreadFunctions.Aberrations([Zernike_Spherical, Zernike_ObliqueAstigmatism],[0.1, 0.2])
Aberrations([12, 3], [0.1, 0.2], :OSA)

julia&gt; pp = PSFParams(580.0, 1.4, 1.518; aberrations=aberr)
PSFParams(580.0, 1.4, 1.518, Float32, ModeWidefield, PointSpreadFunctions.pol_scalar, PointSpreadFunctions.var&quot;#42#43&quot;(), PointSpreadFunctions.MethodPropagateIterative, nothing, Aberrations([12, 3], [0.1, 0.2], :OSA), nothing)

julia&gt; sz = (10,10,64)
(10, 10, 64)

julia&gt; sampling=(190,190,100)
(190, 190, 100)

julia&gt; PointSpreadFunctions.get_zernike_pupil(sz,pp,sampling)
10×10 Matrix{ComplexF64}:
 1.0+0.0im        1.0+0.0im               1.0+0.0im             1.0+0.0im               1.0+0.0im       …          1.0+0.0im             1.0+0.0im               1.0+0.0im             1.0+0.0im
 1.0+0.0im        1.0+0.0im               1.0+0.0im       -0.977799-0.209546im     0.297025+0.95487im         0.478105-0.878303im   0.238146-0.971229im          1.0+0.0im             1.0+0.0im
 1.0+0.0im        1.0+0.0im         -0.989823+0.142305im   0.389073+0.921207im     0.983723+0.179694im     -0.00466964-0.999989im  -0.696362-0.717691im    -0.643318-0.765599im        1.0+0.0im
 1.0+0.0im  -0.977799-0.209546im     0.389073+0.921207im   0.831518+0.555499im     0.894807+0.446453im        0.759688-0.650288im  -0.180764-0.983527im    -0.696362-0.717691im   0.238146-0.971229im
 1.0+0.0im   0.297025+0.95487im      0.983723+0.179694im   0.894807+0.446453im     0.563395+0.826187im        0.926073+0.377344im   0.759688-0.650288im  -0.00466964-0.999989im   0.478105-0.878303im
 1.0+0.0im   0.991619-0.129199im     0.790818-0.612051im   0.994312+0.106505im     0.520607+0.853797im  …     0.520607+0.853797im   0.994312+0.106505im     0.790818-0.612051im   0.991619-0.129199im
 1.0+0.0im   0.478105-0.878303im  -0.00466964-0.999989im   0.759688-0.650288im     0.926073+0.377344im        0.563395+0.826187im   0.894807+0.446453im     0.983723+0.179694im   0.297025+0.95487im
 1.0+0.0im   0.238146-0.971229im    -0.696362-0.717691im  -0.180764-0.983527im     0.759688-0.650288im        0.894807+0.446453im   0.831518+0.555499im     0.389073+0.921207im  -0.977799-0.209546im
 1.0+0.0im        1.0+0.0im         -0.643318-0.765599im  -0.696362-0.717691im  -0.00466964-0.999989im        0.983723+0.179694im   0.389073+0.921207im    -0.989823+0.142305im        1.0+0.0im
 1.0+0.0im        1.0+0.0im               1.0+0.0im        0.238146-0.971229im     0.478105-0.878303im        0.297025+0.95487im   -0.977799-0.209546im          1.0+0.0im             1.0+0.0im
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/8415cb7d3e16c63b8d5d2c339613dbe91f330f3d/src/pupil.jl#L228-L270">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.k_0-Tuple{PSFParams}" href="#PointSpreadFunctions.k_0-Tuple{PSFParams}"><code>PointSpreadFunctions.k_0</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">k_0(pp::PSFParams)</code></pre><p>k in the medium as n/lambda.   (1/space units)</p><p>Arguments:</p><ul><li><code>pp</code>:  PSF parameter structure</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/8415cb7d3e16c63b8d5d2c339613dbe91f330f3d/src/util.jl#L320-L327">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.k_pupil-Tuple{PSFParams}" href="#PointSpreadFunctions.k_pupil-Tuple{PSFParams}"><code>PointSpreadFunctions.k_pupil</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">k_pupil(pp::PSFParams)</code></pre><p>maxim radial (i.e. XY-) k-coordinate (1/space units) where the pupil ends</p><p>Arguments:</p><ul><li><code>pp</code>:  PSF parameter structure</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/8415cb7d3e16c63b8d5d2c339613dbe91f330f3d/src/util.jl#L332-L339">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.k_dz-Tuple{PSFParams}" href="#PointSpreadFunctions.k_dz-Tuple{PSFParams}"><code>PointSpreadFunctions.k_dz</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">k_dz(pp::PSFParams)</code></pre><p>relative kz range from pupil boarder to top of Ewald sphere (in 1/space units)</p><p>Arguments:</p><ul><li><code>pp</code>:  PSF parameter structure</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/8415cb7d3e16c63b8d5d2c339613dbe91f330f3d/src/util.jl#L344-L351">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.k_scale-Tuple{Any, PSFParams, Any}" href="#PointSpreadFunctions.k_scale-Tuple{Any, PSFParams, Any}"><code>PointSpreadFunctions.k_scale</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">k_scale(sz,pp,sampling)
pixelpitch (as NTuple) in k-space</code></pre><ul><li><code>sz</code>:  size of the real-space array</li><li><code>pp</code>:  PSF parameter structure</li><li><code>sampling</code>: pixelpitch in real space as NTuple</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/8415cb7d3e16c63b8d5d2c339613dbe91f330f3d/src/util.jl#L369-L375">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.k_pupil_pos-Tuple{Any, PSFParams, Any}" href="#PointSpreadFunctions.k_pupil_pos-Tuple{Any, PSFParams, Any}"><code>PointSpreadFunctions.k_pupil_pos</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">k_pupil_pos(sz, pp::PSFParams, sampling)</code></pre><p>returns the X and Y position of the pupil border in reciprocal space pixels.</p><p>Arguments:</p><ul><li><code>sz</code>:  size of the real-space array</li><li><code>pp</code>:  PSF parameter structure</li><li><code>sampling</code>: pixelpitch in real space as NTuple</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/8415cb7d3e16c63b8d5d2c339613dbe91f330f3d/src/util.jl#L380-L389">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.k_0_pos-Tuple{Any, PSFParams, Any}" href="#PointSpreadFunctions.k_0_pos-Tuple{Any, PSFParams, Any}"><code>PointSpreadFunctions.k_0_pos</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">k_0_pos(sz, pp::PSFParams, sampling)</code></pre><p>returns the X, Y and Z position of the Ewald-sphere border in reciprocal space pixels.</p><p>Arguments:</p><ul><li><code>sz</code>:  size of the real-space array</li><li><code>pp</code>:  PSF parameter structure</li><li><code>sampling</code>: pixelpitch in real space as NTuple</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/8415cb7d3e16c63b8d5d2c339613dbe91f330f3d/src/util.jl#L394-L403">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.k_r-Tuple{Any, PSFParams, Any}" href="#PointSpreadFunctions.k_r-Tuple{Any, PSFParams, Any}"><code>PointSpreadFunctions.k_r</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">k_r(sz, pp::PSFParams, sampling)</code></pre><p>returns an array of radial k coordinates, |k_xy|</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/8415cb7d3e16c63b8d5d2c339613dbe91f330f3d/src/util.jl#L408-L412">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.k_xy-Tuple{Any, Any, Any}" href="#PointSpreadFunctions.k_xy-Tuple{Any, Any, Any}"><code>PointSpreadFunctions.k_xy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">k_xy(sz,pp,sampling)</code></pre><p>yields a 2D array with each entry being a 2D Tuple.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/8415cb7d3e16c63b8d5d2c339613dbe91f330f3d/src/util.jl#L417-L421">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.k_xy_rel_pupil-Tuple{Any, Any, Any}" href="#PointSpreadFunctions.k_xy_rel_pupil-Tuple{Any, Any, Any}"><code>PointSpreadFunctions.k_xy_rel_pupil</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">k_xy_rel_pupil(sz,pp,sampling)</code></pre><p>returns an array of relative distance to the pupil border</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/8415cb7d3e16c63b8d5d2c339613dbe91f330f3d/src/util.jl#L426-L430">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.get_pupil_aperture" href="#PointSpreadFunctions.get_pupil_aperture"><code>PointSpreadFunctions.get_pupil_aperture</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_pupil_aperture(sz::NTuple, pp::PSFParams, sampling)</code></pre><p>just a convenient function for demonstration purposes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/8415cb7d3e16c63b8d5d2c339613dbe91f330f3d/src/util.jl#L189-L193">source</a></section></article><h2 id="Polarization"><a class="docs-heading-anchor" href="#Polarization">Polarization</a><a id="Polarization-1"></a><a class="docs-heading-anchor-permalink" href="#Polarization" title="Permalink"></a></h2><p>These functions can be conveniently supplied to <code>PSFParams()</code> via the named argument <code>polarization</code>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.pol_scalar" href="#PointSpreadFunctions.pol_scalar"><code>PointSpreadFunctions.pol_scalar</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pol_scalar(T, xypos)</code></pre><p>ignores polarization aspects in the calculation but calculates only based on (high-NA) scalar theory. This is a lot faster but not as accurate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/8415cb7d3e16c63b8d5d2c339613dbe91f330f3d/src/pupil_pol.jl#L5-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.pol_scalar_spiral" href="#PointSpreadFunctions.pol_scalar_spiral"><code>PointSpreadFunctions.pol_scalar_spiral</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pol_scalar_spiral(T, xypos)</code></pre><p>ignores polarization aspects in the calculation but calculates only based on (high-NA) scalar theory. This version still includes a (scalar) phase spiral. This is a lot faster but not as accurate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/8415cb7d3e16c63b8d5d2c339613dbe91f330f3d/src/pupil_pol.jl#L16-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.pol_x" href="#PointSpreadFunctions.pol_x"><code>PointSpreadFunctions.pol_x</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pol_x(T, xypos)</code></pre><p>assumes x-polarization in illumination or an x-oriented polarizer in detection.  In a high-NA objective this is converted into XYZ electric fields at the focus.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/8415cb7d3e16c63b8d5d2c339613dbe91f330f3d/src/pupil_pol.jl#L27-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.pol_y" href="#PointSpreadFunctions.pol_y"><code>PointSpreadFunctions.pol_y</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pol_y(T, xypos)</code></pre><p>assumes y-polarization in illumination or an x-oriented polarizer in detection.  In a high-NA objective this is converted into XYZ electric fields at the focus.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/8415cb7d3e16c63b8d5d2c339613dbe91f330f3d/src/pupil_pol.jl#L37-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.pol_circ" href="#PointSpreadFunctions.pol_circ"><code>PointSpreadFunctions.pol_circ</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pol_circ(T, xypos)</code></pre><p>assumes circular polarization in illumination or an x-oriented polarizer in detection.  In a high-NA objective this is converted into XYZ electric fields at the focus.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/8415cb7d3e16c63b8d5d2c339613dbe91f330f3d/src/pupil_pol.jl#L47-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.pol_circ_spiral" href="#PointSpreadFunctions.pol_circ_spiral"><code>PointSpreadFunctions.pol_circ_spiral</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pol_circ_spiral(T, xypos)</code></pre><p>assumes circular polarization in illumination or an x-oriented polarizer in detection.  This version includes phase spiral defining the local (xypos-dependent) phase of both x and y polarization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/8415cb7d3e16c63b8d5d2c339613dbe91f330f3d/src/pupil_pol.jl#L57-L62">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.pol_circ_tophat" href="#PointSpreadFunctions.pol_circ_tophat"><code>PointSpreadFunctions.pol_circ_tophat</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pol_circ_tophat(T, xypos)</code></pre><p>assumes circular polarization in illumination.  This version includes phase 0/π tophat defining the local (xypos-dependent) phase of both x and y polarization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/8415cb7d3e16c63b8d5d2c339613dbe91f330f3d/src/pupil_pol.jl#L67-L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.pol_circ_quadrant" href="#PointSpreadFunctions.pol_circ_quadrant"><code>PointSpreadFunctions.pol_circ_quadrant</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pol_circ_quadrant(T, xypos)</code></pre><p>assumes circular polarization in illumination.  This version implements quadrant phase steps, which is one version of STED phaseramps.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/8415cb7d3e16c63b8d5d2c339613dbe91f330f3d/src/pupil_pol.jl#L77-L82">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.pol_radial" href="#PointSpreadFunctions.pol_radial"><code>PointSpreadFunctions.pol_radial</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pol_radial(T, xypos)</code></pre><p>assumes radial polarization in (illumination/detection) of at the pupil.</p><p>Example:</p><pre><code class="language-jdoctest hljs">julia&gt; using PointSpreadFunctions, View5D
julia&gt; pp_em = PSFParams(0.532, 1.3, 1.52; mode=ModeWidefield, pol=pol_radial);
julia&gt; h_p = apsf(MethodPropagate, sz, pp_em, sampling=samp);
julia&gt; @vv real.(h_p[:,:,1,3])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/8415cb7d3e16c63b8d5d2c339613dbe91f330f3d/src/pupil_pol.jl#L89-L102">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.pol_radial_annulus" href="#PointSpreadFunctions.pol_radial_annulus"><code>PointSpreadFunctions.pol_radial_annulus</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pol_radial_annulus(T, xypos; r0= 0.8, σ=0.05) # e.g. for STED microscopy</code></pre><p>returns a pupil function with radial polarization and an annulus at relative pupil radius r0 of exponential apodization width σ.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/8415cb7d3e16c63b8d5d2c339613dbe91f330f3d/src/pupil_pol.jl#L170-L174">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.pupil_annulus" href="#PointSpreadFunctions.pupil_annulus"><code>PointSpreadFunctions.pupil_annulus</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pupil_annulus(T, xypos; r0= 0.8, σ=0.05)</code></pre><p>returns a pupil function with an annulus at relative pupil radius r0 of exponential apodization width σ. Note that this pupil function should not be used by itself, but needs to be combined with a polarization function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/8415cb7d3e16c63b8d5d2c339613dbe91f330f3d/src/pupil_pol.jl#L132-L137">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.pupil_apodize_hann" href="#PointSpreadFunctions.pupil_apodize_hann"><code>PointSpreadFunctions.pupil_apodize_hann</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pupil_apodize_hann(T, xypos; r0= 0.9) #</code></pre><p>returns a pupil function with a hanning-type apodization starting at radius r0, extending to the pupil limit. Both, cos-window and Hann window apodization should yield a finite standard deviation of the PSF. Note that this pupil function should not be used by itself, but needs to be combined with a polarization function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/8415cb7d3e16c63b8d5d2c339613dbe91f330f3d/src/pupil_pol.jl#L143-L149">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.pupil_apodize_cos" href="#PointSpreadFunctions.pupil_apodize_cos"><code>PointSpreadFunctions.pupil_apodize_cos</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pupil_apodize_cos(T, xypos; r0= 0.9) #</code></pre><p>returns a pupil function with a cos-type apodization starting at radius r0, extending to the pupil limit. The cos-type apodization reaches zero at the border of the pupil, but with a slope. This cos-filter goes back to Gabor. Both, cos-window and Hann window apodization should yield a finite standard deviation of the PSF. Note that this pupil function should not be used by itself, but needs to be combined with a polarization function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/8415cb7d3e16c63b8d5d2c339613dbe91f330f3d/src/pupil_pol.jl#L156-L163">source</a></section></article><h2 id="Aplanatic-factors"><a class="docs-heading-anchor" href="#Aplanatic-factors">Aplanatic factors</a><a id="Aplanatic-factors-1"></a><a class="docs-heading-anchor-permalink" href="#Aplanatic-factors" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.aplanatic_detection" href="#PointSpreadFunctions.aplanatic_detection"><code>PointSpreadFunctions.aplanatic_detection</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">aplanatic_detection = (θ) -&gt; sqrt.(max.(0,cos.(θ)))</code></pre><p>This is the aplanatic factor typically used in detection of fluorescence of (randomly oriented) fluorophores. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/8415cb7d3e16c63b8d5d2c339613dbe91f330f3d/src/aplanatic.jl#L11-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.aplanatic_illumination" href="#PointSpreadFunctions.aplanatic_illumination"><code>PointSpreadFunctions.aplanatic_illumination</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">aplanatic_illumination = (θ) -&gt; sqrt.(max.(0,cos.(θ)))</code></pre><p>This is the aplanatic factor typically used in illumination of (randomly oriented) fluorophores. Note that it is identical to detection.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/8415cb7d3e16c63b8d5d2c339613dbe91f330f3d/src/aplanatic.jl#L18-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.aplanatic_const" href="#PointSpreadFunctions.aplanatic_const"><code>PointSpreadFunctions.aplanatic_const</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">aplanatic_const = (θ) -&gt; one.(eltype(θ))</code></pre><p>This is a constant aplanatic factor</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/8415cb7d3e16c63b8d5d2c339613dbe91f330f3d/src/aplanatic.jl#L25-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.aplanatic_illumination_flux" href="#PointSpreadFunctions.aplanatic_illumination_flux"><code>PointSpreadFunctions.aplanatic_illumination_flux</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">aplanatic_illumination_flux = (θ) -&gt; max.(0,cos.(θ))</code></pre><p>This refers the aplanatic factor if interested in the flux through a detector perpendicular to the optical axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/8415cb7d3e16c63b8d5d2c339613dbe91f330f3d/src/aplanatic.jl#L32-L36">source</a></section></article><h2 id="Sampling"><a class="docs-heading-anchor" href="#Sampling">Sampling</a><a id="Sampling-1"></a><a class="docs-heading-anchor-permalink" href="#Sampling" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.get_Abbe_limit-Tuple{PSFParams}" href="#PointSpreadFunctions.get_Abbe_limit-Tuple{PSFParams}"><code>PointSpreadFunctions.get_Abbe_limit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_Abbe_limit(pp::PSFParams)</code></pre><p>returns the Abbe limit of incoherent imaging in real space as a Tuple with 3 entries. Note that the coherent limit needs only a factor of two less sampling, as long as no intensity is calculated. This allows upsampling right before calculating intensities.</p><p>See also:</p><ul><li>get<em>required</em>amp_sampling()</li></ul><p>Example:</p><pre><code class="language-jdoctest hljs">julia&gt; using PointSpreadFunctions

julia&gt; pp = PSFParams(580.0, 1.4, 1.518)
PSFParams(580.0, 1.4, 1.518, Float32, ModeWidefield, PointSpreadFunctions.pol_scalar, PointSpreadFunctions.var&quot;#42#43&quot;(), PointSpreadFunctions.MethodPropagateIterative, nothing, Aberrations(Any[], Any[], :OSA), nothing)

julia&gt; PointSpreadFunctions.get_Abbe_limit(pp)
(191.04085f0, 191.04085f0, 622.8464f0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/8415cb7d3e16c63b8d5d2c339613dbe91f330f3d/src/util.jl#L29-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.get_required_amp_sampling-Tuple{Tuple{Vararg{T, N}} where {N, T}, PSFParams}" href="#PointSpreadFunctions.get_required_amp_sampling-Tuple{Tuple{Vararg{T, N}} where {N, T}, PSFParams}"><code>PointSpreadFunctions.get_required_amp_sampling</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_required_amp_sampling(sz::NTuple, pp::PSFParams)</code></pre><p>returns the necessary sampling (in real space) for sampling amplitudes. This is almost corresponding to the Abbe limit. Factor of two less because of amplitude but twice because of the Nyquist theorem.  However, this is slight modified by requiring slightly higher sampling (one empty pixel on each side of Fourier space) to stay clear of ambiguities.</p><p>See also:</p><ul><li>get<em>Abbe</em>limit()</li></ul><p>Example:</p><pre><code class="language-jdoctest hljs">julia&gt; using PointSpreadFunctions

julia&gt; pp = PSFParams(580.0, 1.4, 1.518)
PSFParams(580.0, 1.4, 1.518, Float32, ModeWidefield, PointSpreadFunctions.pol_scalar, PointSpreadFunctions.var&quot;#42#43&quot;(), PointSpreadFunctions.MethodPropagateIterative, nothing, Aberrations(Any[], Any[], :OSA), nothing)

julia&gt; sz = (256,256,64)
(256, 256, 64)

julia&gt; PointSpreadFunctions.get_required_amp_sampling(sz,pp)
(188.05583f0, 188.05583f0, 219.73679f0)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/8415cb7d3e16c63b8d5d2c339613dbe91f330f3d/src/util.jl#L79-L102">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.get_Ewald_sampling-Tuple{Tuple{Vararg{T, N}} where {N, T}, PSFParams}" href="#PointSpreadFunctions.get_Ewald_sampling-Tuple{Tuple{Vararg{T, N}} where {N, T}, PSFParams}"><code>PointSpreadFunctions.get_Ewald_sampling</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_Ewald_sampling(sz::NTuple, pp::PSFParams)</code></pre><p>returns the required minimum sampling for the calculation of a full Ewald sphere.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/8415cb7d3e16c63b8d5d2c339613dbe91f330f3d/src/util.jl#L109-L113">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.check_amp_sampling_xy-Tuple{Any, Any, Any}" href="#PointSpreadFunctions.check_amp_sampling_xy-Tuple{Any, Any, Any}"><code>PointSpreadFunctions.check_amp_sampling_xy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_amp_sampling_xy(sz, pp,sampling)</code></pre><p>issues a warning if the amplitude sampling along X and Y is not within the required limits.</p><p>See also:</p><ul><li>get<em>Abbe</em>limit()</li><li>get<em>required</em>amp_sampling()</li><li>check<em>amp</em>sampling()</li><li>check<em>amp</em>sampling_z()</li></ul><p>Arguments:</p><ul><li><code>sz</code>:  size of the real-space array</li><li><code>pp</code>:  PSF parameter structure</li><li><code>sampling</code>: pixelpitch in real space as NTuple</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/8415cb7d3e16c63b8d5d2c339613dbe91f330f3d/src/util.jl#L446-L461">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.check_amp_sampling_z-Tuple{Any, Any, Any}" href="#PointSpreadFunctions.check_amp_sampling_z-Tuple{Any, Any, Any}"><code>PointSpreadFunctions.check_amp_sampling_z</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_amp_sampling_z(sz, pp,sampling)</code></pre><p>issues a warning if the amplitude sampling along Z is not within the required limits.</p><p>See also:</p><ul><li>get<em>Abbe</em>limit()</li><li>get<em>required</em>amp_sampling()</li><li>check<em>amp</em>sampling_xy()</li><li>check<em>amp</em>sampling()</li></ul><p>Arguments:</p><ul><li><code>sz</code>:  size of the real-space array</li><li><code>pp</code>:  PSF parameter structure</li><li><code>sampling</code>: pixelpitch in real space as NTuple</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/8415cb7d3e16c63b8d5d2c339613dbe91f330f3d/src/util.jl#L474-L489">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.check_amp_sampling-Tuple{Any, Any, Any}" href="#PointSpreadFunctions.check_amp_sampling-Tuple{Any, Any, Any}"><code>PointSpreadFunctions.check_amp_sampling</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_amp_sampling(sz, pp,sampling)</code></pre><p>issues a warning if the amplitude sampling (X,Y and Z) is not within the required limits.</p><p>See also:</p><ul><li>get<em>Abbe</em>limit()</li><li>get<em>required</em>amp_sampling()</li><li>check<em>amp</em>sampling_xy()</li><li>check<em>amp</em>sampling_z()</li></ul><p>Arguments:</p><ul><li><code>sz</code>:  size of the real-space array</li><li><code>pp</code>:  PSF parameter structure</li><li><code>sampling</code>: pixelpitch in real space as NTuple</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/8415cb7d3e16c63b8d5d2c339613dbe91f330f3d/src/util.jl#L506-L521">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.check_amp_sampling_sincr-Tuple{Any, Any, Any}" href="#PointSpreadFunctions.check_amp_sampling_sincr-Tuple{Any, Any, Any}"><code>PointSpreadFunctions.check_amp_sampling_sincr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_amp_sampling_sincr(sz, pp,sampling)</code></pre><p>issues a warning if the amplitude sampling (X,Y and Z) is not within the required limits for the <code>SincR</code> method, as this requires sampling the Ewald-sphere according to Nyquist.</p><p>See also:</p><ul><li>get<em>Abbe</em>limit()</li><li>get<em>required</em>amp_sampling()</li><li>check<em>amp</em>sampling()</li><li>get<em>Ewald</em>sampling()</li></ul><p>Arguments:</p><ul><li><code>sz</code>:  size of the real-space array</li><li><code>pp</code>:  PSF parameter structure</li><li><code>sampling</code>: pixelpitch in real space as NTuple</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/8415cb7d3e16c63b8d5d2c339613dbe91f330f3d/src/util.jl#L527-L543">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.get_Nyquist_limit" href="#PointSpreadFunctions.get_Nyquist_limit"><code>PointSpreadFunctions.get_Nyquist_limit</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_Nyquist_limit(pp::PSFParams)</code></pre><p>returns the Nyquist sampling limit of incoherent imaging in real space as a Tuple with 3 entries. Note that the coherent limit needs only a factor of two less sampling, as long as no intensity is calculated. This allows upsampling right before calculating intensities.</p><p>See also:</p><ul><li>get<em>Abbe</em>limit()</li></ul><p>Example:</p><pre><code class="language-jdoctest hljs">julia&gt; using PointSpreadFunctions

julia&gt; pp = PSFParams(580.0, 1.4, 1.518)
PSFParams(580.0, 1.4, 1.518, Float32, ModeWidefield, PointSpreadFunctions.pol_scalar, PointSpreadFunctions.var&quot;#42#43&quot;(), PointSpreadFunctions.MethodPropagateIterative, nothing, Aberrations(Any[], Any[], :OSA), nothing)

julia&gt; PointSpreadFunctions.get_Nyquist_limit(pp)
(95.520424f0, 95.520424f0, 311.4232f0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/8415cb7d3e16c63b8d5d2c339613dbe91f330f3d/src/util.jl#L55-L74">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.limit_θ" href="#PointSpreadFunctions.limit_θ"><code>PointSpreadFunctions.limit_θ</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">limit_θ(theta, α_max)</code></pre><p>limits the maximum angle to the theoretical α_max. This is particularly important for the 1/sqrt(cos θ) aplanatic factor as this factor diverges and wins over the roundoff errors of the smooth pupil.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/8415cb7d3e16c63b8d5d2c339613dbe91f330f3d/src/pupil.jl#L10-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.limit_theta" href="#PointSpreadFunctions.limit_theta"><code>PointSpreadFunctions.limit_theta</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">limit_theta(θ)
limits the angle to pi/2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/8415cb7d3e16c63b8d5d2c339613dbe91f330f3d/src/aplanatic.jl#L4-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.limit_kz-Tuple{Any, PSFParams, Any}" href="#PointSpreadFunctions.limit_kz-Tuple{Any, PSFParams, Any}"><code>PointSpreadFunctions.limit_kz</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">limit_k_z(ft_shell, pp::PSFParams, sampling)</code></pre><p>limits the k_z range of the ewald-sphere. returns the extracted region and the new sampling</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/8415cb7d3e16c63b8d5d2c339613dbe91f330f3d/src/util.jl#L137-L142">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.pinhole_AU_to_pix" href="#PointSpreadFunctions.pinhole_AU_to_pix"><code>PointSpreadFunctions.pinhole_AU_to_pix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pinhole_AU_to_pix(sz, pp_em, sampling)</code></pre><p>returns the pinhole in AU. Also checks if the pinhole is too big.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/8415cb7d3e16c63b8d5d2c339613dbe91f330f3d/src/PointSpreadFunctions.jl#L294-L298">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.AU_per_pixel" href="#PointSpreadFunctions.AU_per_pixel"><code>PointSpreadFunctions.AU_per_pixel</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">AU_in_pixels(pp, sampling)</code></pre><p>calculates the size of the Airy unites in pixels. #arguments</p><ul><li><code>pp</code>: PSF parameter structure</li><li><code>sampling</code>: sampling of the image pixels in object coordinates</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/8415cb7d3e16c63b8d5d2c339613dbe91f330f3d/src/PointSpreadFunctions.jl#L380-L387">source</a></section></article><h2 id="Utilities"><a class="docs-heading-anchor" href="#Utilities">Utilities</a><a id="Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.amp_to_int-Tuple{Any}" href="#PointSpreadFunctions.amp_to_int-Tuple{Any}"><code>PointSpreadFunctions.amp_to_int</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">amp_to_int(field, pp)</code></pre><p>converts a complex-valued amplitude field to intensity via <code>abs2.</code> and summing over the 4th dimension and dropping the 4th dimension. If <code>pp.transition_dipole</code> is provided, the dipole transition probability is calculated, otherwise a directionally independed effect is assumed.</p><p>#Arguments</p><ul><li>field:    The 4D field to extract the intensity from</li><li>pp:       Is checked for whether <code>pp.transition_dipole</code> is not nothing. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/8415cb7d3e16c63b8d5d2c339613dbe91f330f3d/src/util.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.calc_with_resampling" href="#PointSpreadFunctions.calc_with_resampling"><code>PointSpreadFunctions.calc_with_resampling</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">calc_with_resampling(fct, sz, sampling, args)
calculates a function `fct` on a twice downsampled grid and upsamples the result.</code></pre><p>#Parameters +<code>fct</code>:  Function that performs the calculation. Its first argument needs to be the N-dimensional data size <code>sz</code> and the <code>sampling</code>. +<code>sz</code>:  size of the array to calculate +<code>sampling</code>: pixel sizes of the final array to calculate</p><ul><li><code>norm_amp</code>:  decides whether amplitude or intensity is normalized to account for the size change</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/8415cb7d3e16c63b8d5d2c339613dbe91f330f3d/src/util.jl#L563-L572">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.normalize_amp_to_plane" href="#PointSpreadFunctions.normalize_amp_to_plane"><code>PointSpreadFunctions.normalize_amp_to_plane</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">normalize_amp_to_plane(apsf, plane=nothing, mydim=3)</code></pre><p>normalizes an amplitude PSF such that the intensity sum over the central <code>plane</code> position is one. Dimension <code>mydim</code> defines the coordinate referring the the slicing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/8415cb7d3e16c63b8d5d2c339613dbe91f330f3d/src/util.jl#L552-L556">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.has_z_symmetry-Tuple{PSFParams}" href="#PointSpreadFunctions.has_z_symmetry-Tuple{PSFParams}"><code>PointSpreadFunctions.has_z_symmetry</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">has_z_symmetry(pp::PSFParams)</code></pre><p>checks whether the point spread function is expected to be symmetric along the z-direction. Currently this is defined by the aberration list being empty.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/8415cb7d3e16c63b8d5d2c339613dbe91f330f3d/src/util.jl#L20-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.get_McCutchen_kz_center-Tuple{Any, PSFParams, Any}" href="#PointSpreadFunctions.get_McCutchen_kz_center-Tuple{Any, PSFParams, Any}"><code>PointSpreadFunctions.get_McCutchen_kz_center</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_McCutchen_kz_center(ft_shell, pp::PSFParams, sampling)</code></pre><p>calculates the (rounded) pixels position half way between both, the kz-borders of the McCutchen pupil to extract from the full sized Ewald sphere. The pixel z position is returned together with the corresponding kz position.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/8415cb7d3e16c63b8d5d2c339613dbe91f330f3d/src/util.jl#L121-L126">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.disc_pinhole_ft" href="#PointSpreadFunctions.disc_pinhole_ft"><code>PointSpreadFunctions.disc_pinhole_ft</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">disc_pinhole_ft(sz, pp, pinhole)</code></pre><p>calculates the Fourier transform of a disc-shaped pinhole</p><ul><li><code>pp</code>: PSF parameter structure</li><li><code>sampling</code>: sampling of the image pixels in object coordinates</li><li><code>pinhole</code>: diameter of the pinhole in pixels</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/8415cb7d3e16c63b8d5d2c339613dbe91f330f3d/src/PointSpreadFunctions.jl#L354-L362">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.my_disc-Tuple{Any, Any}" href="#PointSpreadFunctions.my_disc-Tuple{Any, Any}"><code>PointSpreadFunctions.my_disc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">my_disc(sz, pp)</code></pre><p>creates a disc such that there is no overalp upon wrap-around, when convolving it with itself on this grid. This is the radius where there is no overlap. However, in the cornes of the calculation, the results are not 100% accurate as something is missing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/8415cb7d3e16c63b8d5d2c339613dbe91f330f3d/src/util.jl#L288-L294">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.box_pinhole_ft" href="#PointSpreadFunctions.box_pinhole_ft"><code>PointSpreadFunctions.box_pinhole_ft</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">disc_pinhole_ft(sz, pp, pinhole)</code></pre><p>calculates the Fourier transform of a box-shaped pinhole</p><ul><li><code>pp</code>: PSF parameter structure</li><li><code>sampling</code>: sampling of the image pixels in object coordinates</li><li><code>pinhole</code>: tuple of side lengths of the pinhole in pixels</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/8415cb7d3e16c63b8d5d2c339613dbe91f330f3d/src/PointSpreadFunctions.jl#L367-L375">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.sinc_r-Tuple{Tuple{Vararg{T, N}} where {N, T}, PSFParams}" href="#PointSpreadFunctions.sinc_r-Tuple{Tuple{Vararg{T, N}} where {N, T}, PSFParams}"><code>PointSpreadFunctions.sinc_r</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sinc_r(sz::NTuple, pp::PSFParams; sampling=nothing)</code></pre><p>calculates the 3-dimensional <code>sinc(abs(position))</code> scaled such that the Fourier transformation yields the k-sphere. Note that for this to work the sampling needs to be sufficient, which may be problematic especially along the z-direction. This can be checked with the help of the <code>get_Ewald_sampling()</code> function.</p><p>See also:</p><ul><li>get<em>Ewald</em>sampling()</li><li>jinc<em>r</em>2d</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/8415cb7d3e16c63b8d5d2c339613dbe91f330f3d/src/util.jl#L153-L164">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.sinc_r_2d" href="#PointSpreadFunctions.sinc_r_2d"><code>PointSpreadFunctions.sinc_r_2d</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sinc_r_2d(sz::NTuple, side_length=(1.0,1.0), dtype=Float32)</code></pre><p>calculates a sinc(abs(position)) function in 2D such that its inverse Fourier transform corresponds to the box-shaped pupil of <code>diameter</code> which is a Tuple of both long axes diameters. <code>dtype</code> specifies the destination type. Note that the result is normalized such that the disk as obtained by an inverse Fourier transformation is filled with a value of <code>1.0</code>.</p><p>See also:</p><ul><li>sinc_r()</li></ul><p><strong>Example</strong></p><pre><code class="language-jdoctest hljs">julia&gt; using PointSpreadFunctions, View5D

julia&gt; sz = (100,100);d=20.0; w=jinc_r_2d(sz,d); 

julia&gt; q = sinc_r_2d(sz, d; r_func=PointSpreadFunctions.rr_rfft); # a version in RFFT space

julia&gt; @vt rr(sz) .&lt; d/2.0 real.(ift(w)) fftshift(irfft(q,sz[1]))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/8415cb7d3e16c63b8d5d2c339613dbe91f330f3d/src/util.jl#L225-L244">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.jinc_r_2d-Tuple{Tuple{Vararg{T, N}} where {N, T}, PSFParams}" href="#PointSpreadFunctions.jinc_r_2d-Tuple{Tuple{Vararg{T, N}} where {N, T}, PSFParams}"><code>PointSpreadFunctions.jinc_r_2d</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">jinc_r_2d(sz::NTuple, pp::PSFParams; sampling=nothing)</code></pre><p>calculates a jinc(abs(position)) function in 2D such that its Fourier transform corresponds to the disk-shaped pupil (indcluding the effect ot the numerical aperture). If <code>sampling</code> is not provided, sampling is assumed such that the Nyquist sampling would correspond to sampling the wavelength (i.e. the Ewals sphere) correctly for this amplitude.</p><p>See also:</p><ul><li>sinc_r()</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/8415cb7d3e16c63b8d5d2c339613dbe91f330f3d/src/util.jl#L172-L181">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.jinc_r_2d" href="#PointSpreadFunctions.jinc_r_2d"><code>PointSpreadFunctions.jinc_r_2d</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">jinc_r_2d(sz::NTuple, pp::PSFParams; sampling=nothing)</code></pre><p>calculates a jinc(abs(position)) function in 2D such that its Fourier transform corresponds to the disk-shaped pupil (indcluding the effect ot the numerical aperture). If <code>sampling</code> is not provided, sampling is assumed such that the Nyquist sampling would correspond to sampling the wavelength (i.e. the Ewals sphere) correctly for this amplitude.</p><p>See also:</p><ul><li>sinc_r()</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/8415cb7d3e16c63b8d5d2c339613dbe91f330f3d/src/util.jl#L172-L181">source</a></section><section><div><pre><code class="language-julia hljs">jinc_r_2d(sz::NTuple, diameter=(1.0,1.0), dtype=Float32)</code></pre><p>calculates a jinc(abs(position)) function in 2D such that its inverse Fourier transform corresponds to the disk-shaped pupil of <code>diameter</code> which is a Tuple of both long axes diameters. <code>dtype</code> specifies the destination type. Note that the result is normalized such that the disk as obtained by an inverse Fourier transformation is filled with a value of <code>1.0</code>.</p><p>See also:</p><ul><li>sinc_r()</li></ul><p><strong>Example</strong></p><pre><code class="language-jdoctest hljs">julia&gt; using PointSpreadFunctions, View5D

julia&gt; sz = (100,100);d=20.0; w=jinc_r_2d(sz,d); 

julia&gt; q = jinc_r_2d(sz, d; r_func=PointSpreadFunctions.rr_rfft); # a version in RFFT space

julia&gt; @vt rr(sz) .&lt; d/2.0 real.(ift(w)) fftshift(irfft(q,sz[1]))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/8415cb7d3e16c63b8d5d2c339613dbe91f330f3d/src/util.jl#L198-L217">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.iftz-Tuple{Any}" href="#PointSpreadFunctions.iftz-Tuple{Any}"><code>PointSpreadFunctions.iftz</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">iftz(arr)</code></pre><p>inverse Fourier transform only along the 3rd dimension (kz).</p><p>Arguments:</p><ul><li>arr:  array to transform along kz</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/8415cb7d3e16c63b8d5d2c339613dbe91f330f3d/src/util.jl#L298-L305">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.theta_z-Tuple{Any}" href="#PointSpreadFunctions.theta_z-Tuple{Any}"><code>PointSpreadFunctions.theta_z</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">theta_z(sz)</code></pre><p>a θ function along the z direction, being one for z positon &gt; 0 and zero elsewhere.</p><p>Arguments:</p><ul><li>sz:  size of the array</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/8415cb7d3e16c63b8d5d2c339613dbe91f330f3d/src/util.jl#L308-L315">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.xx_rfft" href="#PointSpreadFunctions.xx_rfft"><code>PointSpreadFunctions.xx_rfft</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">xx_rfft(dtype, sz; scale=1.0)
generates the positions in rfft space based on the distance to the zero coordinate. `sz` corresponds to a size of the full (inverse Fourier-transformed) array.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/8415cb7d3e16c63b8d5d2c339613dbe91f330f3d/src/util.jl#L269-L273">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.yy_rfft" href="#PointSpreadFunctions.yy_rfft"><code>PointSpreadFunctions.yy_rfft</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">yy_rfft(dtype, sz; scale=1.0)
generates the positions in rfft space based on the distance to the zero coordinate. `sz` corresponds to a size of the full (inverse Fourier-transformed) array.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/8415cb7d3e16c63b8d5d2c339613dbe91f330f3d/src/util.jl#L276-L280">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.rr_rfft" href="#PointSpreadFunctions.rr_rfft"><code>PointSpreadFunctions.rr_rfft</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rr_rfft(dtype, sz; scale=1.0)
generates the positions in rfft space based on the distance to the zero coordinate. `sz` corresponds to a size of the full (inverse Fourier-transformed) array.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/8415cb7d3e16c63b8d5d2c339613dbe91f330f3d/src/util.jl#L262-L266">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.to_rfft_pos" href="#PointSpreadFunctions.to_rfft_pos"><code>PointSpreadFunctions.to_rfft_pos</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">to_rfft_pos(fct, dtype, sz; scale=1.0)</code></pre><p>converts an IdxFunArray function such that it works for rft arrays. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/8415cb7d3e16c63b8d5d2c339613dbe91f330f3d/src/util.jl#L252-L256">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.confocal_int" href="#PointSpreadFunctions.confocal_int"><code>PointSpreadFunctions.confocal_int</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">confocal_int(psf_ex, psf_em, pinhole=nothing, pinhole_ft=disc_pinhole_ft, sampling=nothing, use_resampling=true, return_amp=nothing, pinhole_positions=[(0.0,0.0)], ex_modifier=modify_ident)</code></pre><p>helper function to calculate the confocal detection, once the excitation and emission PSFs and pinhole parameters are defined. Two photon excitation and ISM detection are also included.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/8415cb7d3e16c63b8d5d2c339613dbe91f330f3d/src/PointSpreadFunctions.jl#L315-L319">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.kz_mid_pos" href="#PointSpreadFunctions.kz_mid_pos"><code>PointSpreadFunctions.kz_mid_pos</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">kz_mid_pos(sz, pp::PSFParams, sampling)

reciprocal space distance from the center, where the mid-point between top and bottom of the McCutchen pupil is.</code></pre><p>Arguments:</p><ul><li><code>sz</code>:  Size of the dataset</li><li><code>pp</code>:  PSF parameter structure</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/8415cb7d3e16c63b8d5d2c339613dbe91f330f3d/src/util.jl#L356-L364">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.exp_ikx_rfft" href="#PointSpreadFunctions.exp_ikx_rfft"><code>PointSpreadFunctions.exp_ikx_rfft</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">exp_ikx_rfft(dtype, sz; shift_by)</code></pre><p>calculates the exp factor for an rfft to result into shifting the corresponding real array by <code>shift_by</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/8415cb7d3e16c63b8d5d2c339613dbe91f330f3d/src/PointSpreadFunctions.jl#L394-L398">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.size_sampling_to3d" href="#PointSpreadFunctions.size_sampling_to3d"><code>PointSpreadFunctions.size_sampling_to3d</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">size_sampling_to3d()</code></pre><p>converts size and sampling to 3d vectors</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/8415cb7d3e16c63b8d5d2c339613dbe91f330f3d/src/util.jl#L435-L439">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../workflow/PSF_generation/">« PointSpreadFunction calculation</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.3.0 on <span class="colophon-date" title="Saturday 17 May 2025 07:52">Saturday 17 May 2025</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
