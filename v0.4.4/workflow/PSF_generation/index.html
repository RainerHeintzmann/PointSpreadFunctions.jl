<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>PointSpreadFunction calculation · PSFs Documentation</title><meta name="title" content="PointSpreadFunction calculation · PSFs Documentation"/><meta property="og:title" content="PointSpreadFunction calculation · PSFs Documentation"/><meta property="twitter:title" content="PointSpreadFunction calculation · PSFs Documentation"/><meta name="description" content="Documentation for PSFs Documentation."/><meta property="og:description" content="Documentation for PSFs Documentation."/><meta property="twitter:description" content="Documentation for PSFs Documentation."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">PSFs Documentation</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">PointSpreadFunctions.jl</a></li><li><span class="tocitem">Workflow</span><ul><li><a class="tocitem" href="../PSF_parameters/">PointSpreadFunction parameters</a></li><li class="is-active"><a class="tocitem" href>PointSpreadFunction calculation</a><ul class="internal"><li><a class="tocitem" href="#Excitation-Modifications"><span>Excitation Modifications</span></a></li></ul></li></ul></li><li><span class="tocitem">Function references</span><ul><li><a class="tocitem" href="../../function_references/all_functions/">List of Functions</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Workflow</a></li><li class="is-active"><a href>PointSpreadFunction calculation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>PointSpreadFunction calculation</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/main/docs/src/workflow/PSF_generation.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="PointSpreadFunction-calculation"><a class="docs-heading-anchor" href="#PointSpreadFunction-calculation">PointSpreadFunction calculation</a><a id="PointSpreadFunction-calculation-1"></a><a class="docs-heading-anchor-permalink" href="#PointSpreadFunction-calculation" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.psf" href="#PointSpreadFunctions.psf"><code>PointSpreadFunctions.psf</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">psf(::Type{ModeWidefield}, sz::NTuple, pp::PSFParams; sampling=get_sampling(sz, pp))</code></pre><p>Calculates the widefield single-frequency point spread function (psf), i.e. the image of a single (very small) emitter.  Most of the parameters (such as refractive index, numerical aperture, vacuum wavelength, aberrations etc.) are hidden in the  parameter structure argument <code>pp</code>, which should be generated via the <code>PSFParams()</code> constructor. See `<code>PSFParams()</code> for details.</p><p><strong>Parameters</strong></p><ul><li><code>sz</code>:         size tuple of the final PSF</li><li><code>pp</code>:         PSF parameters of the PSF. See <code>PSFParams()</code> for details. The argument <code>pp.aplanatic</code> defined whether an excitation or emission PSF is calculated.</li><li><code>sampling=nothing</code>:   The sampling parameters of the resulting PSF. If <code>nothing</code> is provided, the PSF will be sampled according to the Abbe limit.</li><li><code>use_resampling=true</code>: Exploits a calculation trick, which first calculates the amplitudes are calculated on a twice coarser grid and the result is upsampled. This increases the speed but may be less accurate.</li><li><code>return_amp=false</code>:    Has to be <code>false</code> since confocal amplitude spread functions do not exist for non-zero pinhole sizes. </li></ul><p>See also:</p><ul><li><code>apsf</code>:  calculates the underlying amplitude point spread function (apsf)</li></ul><p>Example:</p><pre><code class="language-julia-repl hljs">julia&gt; pp = PSFParams(0.5,1.4,1.52); sz=(128,128,128); sampling=(0.050,0.050,0.200);
# an emission PSF of an isotropic (freely rotating emitter)

julia&gt; p_wf = psf(sz, pp; sampling=sampling);
# an emission PSF of an emitter oriented along the Z direction

julia&gt; pp_dipole = PSFParams(0.5,1.4,1.52; transition_dipole=[0.0,0.0,1.0]);

julia&gt; p_dipole = psf(sz, pp_dipole; sampling=sampling);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/ae3d23e5d59471cde53bc69e45a6c34dddbebcdd/src/PointSpreadFunctions.jl#L22-L52">source</a></section><section><div><pre><code class="language-julia hljs">psf(::Type{ModeConfocal}, sz::NTuple, pp_em::PSFParams; pp_ex=nothing, pinhole=nothing, pinhole_ft=disc_pinhole_ft, sampling=nothing, use_resampling=true, return_amp=false, pinhole_positions=[(0.0,0.0)], ex_modifier=modify_ident) # unclear why the resampling seems to be so bad</code></pre><p>Calculates a confocal point spread function. The normalisation is such that a completely open <code>pinhole</code> diameter yields the excitation PSF with its normalization.  Returns the PSF or a vector of PSFs.</p><p><strong>Parameters</strong></p><ul><li><code>sz</code>:         size tuple of the final PSF</li><li><code>pp_em</code>:      PSF parameters of the emission PSF. PSF parameters of the PSF. See <code>PSFParams()</code> for details. This should include the emission wavelength</li><li><code>pp_ex=nothing</code>:      This is a required named parameter, containing all the settings for the excitation PSF. This should include the excitation wavelength as well as typically <code>aplanatic=aplanatic_illumination</code>.</li><li><code>pinhole=nothing</code>:    The diameter of the pinhole in Airy Units (AU = 1.22 λ/NA). A pinhole size of one AU corresponds to a pinhole border falling onto the first zero of a corresponding paraxial emission PSF.</li><li><code>sampling=nothing</code>:   The sampling parameters of the resulting PSF.</li><li><code>use_resampling=true</code>: Exploits a calculation trick, which first calculates the individual PSFs on a twice coarser grid in XY and Z and then upsamples the result. Note that this may be inappropriate due to undersampling due to the Stokes shift which is neglected here. But warnings will then result during the calculations of the subsampled widefield PSFs.</li><li><code>return_amp=false</code>:    Has to be <code>false</code> since confocal amplitude spread functions do not exist for non-zero pinhole sizes. </li><li><code>pinhole_positions=[(0.0,0.0)]</code>:  A list of pinhole positions in pixels. One PSF will be returned for each pinhole position. If only a single pinhole position is supplied the PSF will directly be returned instead of a vector of PSFs. Specifies the precise position(s) of the pinholes in the detection path. This allows to simulate an offset (misadjusted) pinhole, or (as a vector of tuples) a PSF for a whole set of positions. See the <code>psf(ModeISM, ...)</code> for more details. </li><li><code>pinhole_ft=disc_pinhole_ft</code>:  Specifies which function is used to calculate the Fourier transform of the pinhole. This allows the user to control the pinhole shape. </li><li><code>ex_modifier</code>:   A function that can modify the excitation PSF. By default the identity is used, but other options are <code>modify_square</code> to calculate a two-photon confocal PSF. However, you should typically use the <code>Mode2Photon</code> to do this. Note that the order of the PSFParams are reversed.   By default (modify_ident), no modication is performed.</li></ul><pre><code class="language-julia-repl hljs">julia&gt; pp_em = PSFParams(0.5,1.4,1.52; mode=ModeConfocal);
julia&gt; pp_ex = PSFParams(pp_em; λ=0.488, aplanatic=aplanatic_illumination);
julia&gt; p_conf = psf((128,128,128),pp_em; pp_ex=pp_ex, pinhole=0.1, sampling=(0.040,0.040,0.100));</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/ae3d23e5d59471cde53bc69e45a6c34dddbebcdd/src/PointSpreadFunctions.jl#L74-L98">source</a></section><section><div><pre><code class="language-julia hljs">psf(::Type{ModeLightsheet}, sz::NTuple, pp_em::PSFParams; pp_ex=nothing, sampling=nothing, use_resampling=true, dynamically_scanned=false) # unclear why the resampling seems to be so bad</code></pre><p>Calculates a point spread function for a lightsheet microscopy. Not that the coordinate system refers to the detection PSF. The NA of the  excitation PSF refers to the Z and Y direction. The polarisation of the excitation PSF along X means along Z and along Y means along Y in the final volume. Note that the excitation is assumed for the best focus position (beam waist). In reality the PSF will be spatially dependent due to the excitation focus.</p><p><strong>Parameters</strong></p><ul><li><code>sz</code>:         size tuple of the final PSF</li><li><code>pp_em</code>:      PSF parameters of the emission PSF. PSF parameters of the PSF. See <code>PSFParams()</code> for details. This should include the emission wavelength</li><li><code>pp_ex=nothing</code>:      This is a required named parameter, containing all the settings for the excitation PSF. This should include the excitation wavelength as well as typically <code>aplanatic=aplanatic_illumination</code>.</li><li><code>pinhole=nothing</code>:    The diameter of the pinhole in Airy Units (AU = 1.22 λ/NA). A pinhole size of one AU corresponds to a pinhole border falling onto the first zero of a corresponding paraxial emission PSF.</li><li><code>sampling=nothing</code>:   The sampling parameters of the resulting PSF.</li><li><code>use_resampling=true</code>: Exploits a calculation trick, which first calculates the individual PSFs on a twice coarser grid in XY and Z and then upsamples the result. Note that this may be inappropriate due to undersampling due to the Stokes shift which is neglected here. But warnings will then result during the calculations of the subsampled widefield PSFs.</li><li>&#39;dynamically_scanned&#39;: specifies, whether the lightsheet uses a dynamically scanned beam. This is important for the calculation of the PSF. If the beam is scanned, the PSF will be calculated in the same way as for a confocal PSF. If the beam is not scanned, the excitation PSF will be assuming a focussing via a cylinder lens.</li><li><code>ex_modifier</code>:   A function that can modify the excitation PSF. By default the identity is used, but other options are <code>modify_square</code> to calculate a two-photon confocal PSF. However, you should typically use the <code>Mode2Photon</code> to do this. Note that the order of the PSFParams are reversed.   By default (modify_ident), no modication is performed.</li><li>sigma<em>z = nothing: If the user provides a sigma</em>z value, the excitation calculation is using a Guassian excitation PSF with the specified sigma. pp_ex is ignored.</li></ul><pre><code class="language-julia-repl hljs">julia&gt; pp_em = PSFParams(0.5,0.9,1.33; mode=ModeLightsheet);
julia&gt; pp_ex = PSFParams(0.488, 0.2, 1.33);
julia&gt; p_lightsheet = psf((128,128,128), pp_em; pp_ex=pp_ex, sampling=(0.040,0.040,0.100), dynamically_scanned=true);
julia&gt; p_lightsheet_gauss = psf((128,128,128), pp_em; sampling=(0.040,0.040,0.100), sigma_z=1.0); # Gaussian excitation PSF</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/ae3d23e5d59471cde53bc69e45a6c34dddbebcdd/src/PointSpreadFunctions.jl#L146-L171">source</a></section><section><div><pre><code class="language-julia hljs">psf(::Type{ModeISM}, sz::NTuple, pp_em::PSFParams; pinhole=nothing, sampling=nothing, pinhole_ft=box_pinhole_ft, pinhole_positions=[(0.0,0.0)], pinhole_dist=0.5, pinhole_grid=(5,5), ism_pos=ism_positions_rect, args...)</code></pre><p>Calculates a confocal point spread function. The normalisation is such that a completely open <code>pinhole</code> diameter yields the excitation PSF with its normalization.  Returns the PSF or a vector of PSFs.</p><p><strong>Parameters</strong></p><ul><li><code>sz</code>:         size tuple of the final PSF</li><li><code>pp_em</code>:      PSF parameters of the emission PSF. This should include the emission wavelength</li><li><code>pp_ex=nothing</code>:      This is a required named parameter, containing all the settings for the excitation PSF. This should include the excitation wavelength as well as typically <code>aplanatic=aplanatic_illumination</code>.</li><li><code>pinhole=nothing</code>:   The diameter of each pinhole in Airy Units (AU = 1.22 λ/NA). By default (pinholes=nothing) the pinhole size is automatically calculated by the <code>pinhole_dist</code> parameter below to yield mutually touching pinholes.</li><li><code>sampling=nothing</code>:   The sampling parameters of the resulting PSF.</li><li><code>use_resampling=true</code>: Exploits a calculation trick, which first calculates the individual PSFs on a twice coarser grid in XY and Z and then upsamples the result. Note that this may be inappropriate due toundersampling due to the Stokes shift which is neglected here. But warnings will then result during the calculations of the subsampled widefield PSFs.</li><li><code>return_amp=false</code>:    Has to be <code>false</code> since confocal amplitude spread functions do not exist for non-zero pinhole sizes. </li><li><code>pinhole_positions=nothing</code>:  A list of pinhole positions in pixel coordinates. One PSF will be returned for each pinhole position. If only a single pinhole position is supplied the PSF will directly be returned instead of a vector of PSFs. Be careful, since this is not the same as the position of the relative shift of the images.</li><li><code>pinhole_dist=0.5</code>: a value or tuple specified the distances between pinholes, when arranged in a grid. </li><li><code>pinhole_ft=box_pinhole_ft</code>:  Specifies which function is used to calculate the Fourier transform of the pinhole. This allows the user to control the pinhole shape. E.g. hexagonal pattern with round pinholes</li></ul><pre><code class="language-julia-repl hljs">julia&gt; sz=(128,128,128); sampling = (0.04,0.04,0.120)
julia&gt; pp_em = PSFParams(0.5,1.4,1.52; mode=ModeISM);
julia&gt; pp_ex = PSFParams(pp_em; λ=0.488, aplanatic=aplanatic_illumination);
julia&gt; p_ism = psf(sz,pp_em; pp_ex=pp_ex, pinhole=0.21, pinhole_dist=0.2, sampling=sampling);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/ae3d23e5d59471cde53bc69e45a6c34dddbebcdd/src/PointSpreadFunctions.jl#L410-L434">source</a></section><section><div><pre><code class="language-julia hljs">psf(::Type{Mode2Photon}, sz::NTuple, pp_ex::PSFParams; pp_em=nothing, pinhole=nothing, sampling=nothing, pinhole_ft=disc_pinhole_ft, args...)</code></pre><p>Calculates a 2-photon (potentially confocal) point spread function.   Returns the PSF or a vector of PSFs.</p><p><strong>Parameters</strong></p><ul><li><code>sz</code>:         size tuple of the final PSF</li><li><code>pp_ex</code>:      PSF parameters of the excitation PSF. This should include the exission wavelength (typically in the IR region). Please make sure to also set <code>pp.aplanatic=aplanatic_illumination</code>.</li><li><code>pp_em</code>:      PSF parameters of the emission PSF. This only needs to be supplied, if a pinhole is used. Otherwise non-descanned detection (NDD) is assumed.</li><li><code>pinhole=nothing</code>:   If <code>nothing</code>, NDD is assumed and the PSF is only the square of the excitation PSF. The diameter of each pinhole in Airy Units (AU = 1.22 λ/NA). </li><li><code>sampling=nothing</code>:   The sampling parameters of the resulting PSF.</li><li><code>use_resampling=true</code>: Exploits a calculation trick, which first calculates the individual PSFs on a twice coarser grid in XY and Z and then upsamples the result. Note that this may be inappropriate due toundersampling due to the Stokes shift which is neglected here. But warnings will then result during the calculations of the subsampled widefield PSFs.</li><li><code>return_amp=false</code>:    Has to be <code>false</code> since confocal amplitude spread functions do not exist for non-zero pinhole sizes. </li><li><code>pinhole_positions=[(0.0,0.0)]</code>:  A list of pinhole positions in pixels. One PSF will be returned for each pinhole position. If only a single pinhole position is supplied the PSF will directly be returned instead of a vector of PSFs.</li></ul><pre><code class="language-julia-repl hljs">julia&gt; sz=(128,128,128); sampling = (0.04,0.04,0.120)
julia&gt; pp_ex = PSFParams(0.8,1.4,1.52; mode=Mode2Photon, aplanatic= aplanatic_illumination);
julia&gt; p_2p = psf(sz,pp_ex; sampling=sampling);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/ae3d23e5d59471cde53bc69e45a6c34dddbebcdd/src/PointSpreadFunctions.jl#L453-L474">source</a></section><section><div><pre><code class="language-julia hljs">psf(::Type{ModeSTED}, sz::NTuple, pp_ex::PSFParams, pp_sted::PSFParams; pp_em=nothing, pinhole=nothing, sampling=nothing, pinhole_ft=disc_pinhole_ft, args...)</code></pre><p>Calculates a 2-photon (potentially confocal) point spread function.   Returns the PSF or a vector of PSFs.</p><p><strong>Parameters</strong></p><ul><li><code>sz</code>:         size tuple of the final PSF</li><li><code>pp_ex</code>:      PSF parameters of the excitation PSF. This should include the exission wavelength (typically in the IR region). Please make sure to also set <code>pp.aplanatic=aplanatic_illumination</code>.</li><li><code>pp_sted</code>:      PSF parameters of the excitation PSF. This should include the exission wavelength (typically in the IR region). Please make sure to also set <code>pp.aplanatic=aplanatic_illumination</code>.</li><li><code>pp_em</code>:      PSF parameters of the emission PSF. This only needs to be supplied, if a pinhole is used. Otherwise non-descanned detection (NDD) is assumed.</li><li><code>pinhole=nothing</code>:   If <code>nothing</code>, NDD is assumed and the PSF is only the square of the excitation PSF. The diameter of each pinhole in Airy Units (AU = 1.22 λ/NA). </li><li><code>sampling=nothing</code>:   The sampling parameters of the resulting PSF.</li><li><code>use_resampling=true</code>: Exploits a calculation trick, which first calculates the individual PSFs on a twice coarser grid in XY and Z and then upsamples the result. Note that this may be inappropriate due toundersampling due to the Stokes shift which is neglected here. But warnings will then result during the calculations of the subsampled widefield PSFs.</li><li><code>return_amp=false</code>:    Has to be <code>false</code> since confocal amplitude spread functions do not exist for non-zero pinhole sizes. </li><li><code>pinhole_positions=[(0.0,0.0)]</code>:  A list of pinhole positions in pixels. One PSF will be returned for each pinhole position. If only a single pinhole position is supplied the PSF will directly be returned instead of a vector of PSFs.</li></ul><pre><code class="language-julia-repl hljs">julia&gt; sz=(128,128,128); sampling = (0.04,0.04,0.120)
julia&gt; pp_em = PSFParams(0.510,1.4,1.52; mode=ModeSTED); # STED suppression beam
julia&gt; pp_ex = PSFParams(0.488,1.4,1.52; aplanatic= aplanatic_illumination);
julia&gt; pp_sted = PSFParams(0.570,1.4,1.52; method=MethodPropagateIterative, aplanatic= aplanatic_illumination, pol=pol_circ_spiral);
julia&gt; p_sted_01 = psf(sz, pp_em; pp_ex=pp_ex, pinhole= 2.0, sampling=sampling, pp_sted=pp_sted, rel_sted_intensity=0.1);
julia&gt; p_sted_1 = psf(sz, pp_em; pp_ex=pp_ex, pinhole= 2.0, sampling=sampling, pp_sted=pp_sted, rel_sted_intensity=1.0);
julia&gt; p_sted_5 = psf(sz, pp_em; pp_ex=pp_ex, pinhole= 2.0, sampling=sampling, pp_sted=pp_sted, rel_sted_intensity=5.0);
julia&gt; pp_sted_b = PSFParams(0.570,1.4,1.52; method=MethodPropagateIterative, aplanatic= aplanatic_illumination, pol=pol_circ_tophat);
julia&gt; p_sted_b5 = psf(sz, pp_em; pp_ex=pp_ex, pinhole= 2.0, sampling=sampling, pp_sted=pp_sted_b, rel_sted_intensity=5.0);
julia&gt; using View5D; @vt p_sted_01 p_sted_1 p_sted_5 p_sted_b5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/ae3d23e5d59471cde53bc69e45a6c34dddbebcdd/src/PointSpreadFunctions.jl#L483-L513">source</a></section><section><div><pre><code class="language-julia hljs">psf(::Type{Mode4Pi}, sz::NTuple, pp_ex::PSFParams; sampling=nothing, pp_ex2=pp_ex, pp_em=nothing, pp_em2=nothing, rel_ex_phase = 0.0, rel_em_phase = 0.0, pinhole=nothing, pinhole_ft=disc_pinhole_ft, pinhole_positions=[(0.0,0.0)], ex_modifier=modify_square)</code></pre><p>Calculates a 4Pi point spread function. Note that the default is using a two-photon excitation. Returns the PSF or a vector of PSFs.</p><p><strong>Parameters</strong></p><ul><li><code>sz</code>:         size tuple of the final PSF</li><li><code>pp_ex</code>:      PSF parameters of the excitation PSF. This should include the exission wavelength (typically in the IR region). Please make sure to also set <code>pp.aplanatic=aplanatic_illumination</code>.</li><li><code>pp_ex2</code>:     PSF parameters of the other side excitation PSF. If <code>nothing</code> is provided, single-sided excitation (e.g. 4Pi Type B) is assumed.</li><li><code>ex_modifier=modify_square</code>:  If <code>modify_square</code>, two-photon excitation is assumed. Use <code>modify_ident</code> for single-photon excitation.</li><li><code>pp_em</code>:      PSF parameters of the emission PSF. This only needs to be supplied, if a pinhole is used.</li><li><code>pp_em2</code>:     PSF parameters of the other side emission PSF. If <code>nothing is supplied, Type A 4Pi microscopy is assumed with single-sided (or incoherent) detection.</code></li><li><code>pinhole=nothing</code>:   If <code>nothing</code>, NDD is assumed and the PSF is only the square of the excitation PSF. The diameter of each pinhole in Airy Units (AU = 1.22 λ/NA). </li><li><code>sampling=nothing</code>:   The sampling parameters of the resulting PSF.</li><li><code>pinhole_positions=[(0.0,0.0)]</code>:  A list of pinhole positions in pixels. One PSF will be returned for each pinhole position. If only a single pinhole position is supplied the PSF will directly be returned instead of a vector of PSFs.</li></ul><pre><code class="language-julia-repl hljs">julia&gt; sampling = (0.04,0.04,0.04)
julia&gt; sz = (128,128,128)
julia&gt; pp_em = PSFParams(0.5,1.3,1.52; mode=Mode4Pi, pol=pol_x);
julia&gt; pp_ex = PSFParams(0.800,1.3,1.52; aplanatic=aplanatic_illumination, mode=Mode4Pi, pol=pol_x);
julia&gt; @time p_4pi = psf(sz,pp_ex; pp_ex2=pp_ex, pp_em=pp_em, pp_em2=pp_em, sampling=sampling, pinhole=2.0, ex_modifier=modify_square);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/ae3d23e5d59471cde53bc69e45a6c34dddbebcdd/src/PointSpreadFunctions.jl#L525-L549">source</a></section><section><div><pre><code class="language-julia hljs">psf(sz::NTuple, pp::PSFParams; sampling=get_sampling(sz, pp))</code></pre><p>Calculates the point spread function (psf), i.e. the image of a single (very small) emitter. Most of the parameters (such as refractive index, numerical aperture, vacuum wavelength, aberrations etc.) are hidden in the parameter structure argument <code>pp</code>, which should be generated via the <code>PSFParams()</code> constructor. See `<code>PSFParams()</code> for details. Note that the field <code>pp.mode</code> defines the microscopic mode to simulate. Currently implemented are the default <code>ModeWidefield</code> and <code>ModeConfocal</code>.</p><p>See also:</p><ul><li>apsf():  calculates the underlying amplitude point spread function (apsf)</li></ul><p>Example:</p><pre><code class="language-julia-repl hljs">julia&gt; pp = PSFParams(0.5,1.4,1.52);
julia&gt; p = psf((128,128,128),pp; sampling=(0.050,0.050,0.200));</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/ae3d23e5d59471cde53bc69e45a6c34dddbebcdd/src/PointSpreadFunctions.jl#L611-L627">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.apsf" href="#PointSpreadFunctions.apsf"><code>PointSpreadFunctions.apsf</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">apsf(::Type{MethodParaxial}, sz::NTuple, pp::PSFParams; sampling=nothing) 
Calculates a paraxial amplitude PSF. Typically `pp.polarization` should be `pol_scalar`. However, other polarisation types yield two channels in the 4th dimension.
One for X and one for Y polarisation. In the paraxial approximation there is no Z polarisation.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/ae3d23e5d59471cde53bc69e45a6c34dddbebcdd/src/aPSFs.jl#L2-L6">source</a></section><section><div><pre><code class="language-julia hljs">apsf(::Type{MethodCZT}, sz::NTuple, pp::PSFParams; sampling=nothing, center_kz=false) 
Calculate amplitude PSF using Chrip-Z transform. the PSF at a given z_depth requires a bigger window to avoid or reduce wrap-around effect of FFT operation.
Firstly given an input parameter z_depth to calculate the xy_plane zoom factor c then apply on the pupil based on the desired depth. Calculate the inverse CZT of the 
field at pupil and zoom-out by the factor c.
+ z_depth: Z-Position from the focus to propagate to. If calcualte 3D apsf (sz[3] is larger than one), a stack is generated with z_depth being the position of the middle (floor.(size/2)) slice.
+ c_want: plane zoom factor only vary by λ, NA, sampling and z_depth. c_allow = λ/(NA*sampling)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/ae3d23e5d59471cde53bc69e45a6c34dddbebcdd/src/aPSFs.jl#L14-L21">source</a></section><section><div><pre><code class="language-julia hljs">apsf(sz::NTuple, pp::PSFParams; sampling=nothing, center_kz=false)</code></pre><p>dispatches to various amplitude point spread function calculation routines. Note that the <code>method</code> entry in <code>pp</code> defines which calculation method to be used. Alternatively a different method can be chosen like this: <code>apsf(::Type{MethodShell}, sz, ..)</code>.</p><p>Arguments:</p><ul><li>sz: NTuple of size to generate</li><li>pp: PSF parameter structure, also contains the dtype. See PSFParam() for details</li><li>sampling: NTuple for pixel pitch information</li><li>center_kz: if true, the McCutchen pupil will be centered along the kz direction. This is important to be able to apply a consecutive resampling without errors.            However, the phase values are then not correct, which does not matter for intensity PSFs.</li></ul><p>See also:</p><ul><li>psf():    calculates the intensity point spread function (psf) by taking (sum along field components of) the absolute square of the corresponding apsf. </li></ul><p>Example:</p><pre><code class="language-jdoctest hljs">julia&gt; pp = PSFParams(500.0,1.4,1.52)
julia&gt; p = apsf((128,128,128),pp; sampling=(50,50,100));</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/ae3d23e5d59471cde53bc69e45a6c34dddbebcdd/src/aPSFs.jl#L562-L584">source</a></section></article><h2 id="Excitation-Modifications"><a class="docs-heading-anchor" href="#Excitation-Modifications">Excitation Modifications</a><a id="Excitation-Modifications-1"></a><a class="docs-heading-anchor-permalink" href="#Excitation-Modifications" title="Permalink"></a></h2><p>These excitation modifications will be applied to incorporate the photophysics of the excitation process. This is particularly relevant for non-linear excitation effects such as exploited in two-photon excitation <code>modify_square</code> or stimulated emission depletion (STED) <code>modify_STED_exp</code>, <code>modify_STED_hyper</code>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.modify_ident" href="#PointSpreadFunctions.modify_ident"><code>PointSpreadFunctions.modify_ident</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">modify_ident(h)</code></pre><p>A function from a series of modficator functions which serve to modify the excitation intensity.     This particular version does nothing. It just returns the input <code>h</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/ae3d23e5d59471cde53bc69e45a6c34dddbebcdd/src/PointSpreadFunctions.jl#L247-L252">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.modify_square" href="#PointSpreadFunctions.modify_square"><code>PointSpreadFunctions.modify_square</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">modify_square(h)</code></pre><p>A function from a series of modficator functions which serve to modify the excitation intensity.     This version returns the absolute square of the input <code>h</code>. It is useful for two-photon microscopy. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/ae3d23e5d59471cde53bc69e45a6c34dddbebcdd/src/PointSpreadFunctions.jl#L257-L262">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.modify_STED_exp" href="#PointSpreadFunctions.modify_STED_exp"><code>PointSpreadFunctions.modify_STED_exp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">modify_STED_exp(h, h_doughnut)</code></pre><p>A function from a series of modficator functions which serve to modify the excitation intensity. This version applies a second STED PSF <code>h_doughnut</code> to deplete the excitation PSF <code>h</code>. The depletion is modeled by an exponential decay as obtained by a relatively short STED pulse following a very short excitation pulse. Note the <code>h_doughnut</code> should be the depletion PSF. Note that this function should be used as a tool to define a new function with fixed second argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/ae3d23e5d59471cde53bc69e45a6c34dddbebcdd/src/PointSpreadFunctions.jl#L267-L274">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PointSpreadFunctions.modify_STED_hyper" href="#PointSpreadFunctions.modify_STED_hyper"><code>PointSpreadFunctions.modify_STED_hyper</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">modify_STED_hyper(h, h_doughnut)</code></pre><p>A function from a series of modficator functions which serve to modify the excitation intensity.     This version applies a second STED psf <code>h_doughnut</code> to deplete the excitation psf <code>h</code>.     The depletion is modeled by an hyperbolic saturation curve based on anaylsing the steady-state kinetics.     This is mostly suitable for CW-STED.     Note the <code>h_doughnut</code> should be the depletion PSF. Note that this function should be used as a tool to define a new function with fixed second argument.     The normalizations are such that <code>h</code> as well as <code>h_doughnut</code> reache 50% saturation at <code>h==1.0</code>. This means that typically your want to use     <code>max(h) &lt;&lt; 1</code> and <code>max(h_doughnut) &gt;&gt; 1</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PointSpreadFunctions.jl/blob/ae3d23e5d59471cde53bc69e45a6c34dddbebcdd/src/PointSpreadFunctions.jl#L279-L289">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../PSF_parameters/">« PointSpreadFunction parameters</a><a class="docs-footer-nextpage" href="../../function_references/all_functions/">List of Functions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.3.0 on <span class="colophon-date" title="Saturday 17 May 2025 08:59">Saturday 17 May 2025</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
